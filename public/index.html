<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>$ok ‚Äî The ok Crying Cat</title>
    <meta
      name="description"
      content="$ok ‚Äî The Internet's Emotional Punctuation. A timeless, tier-1 reaction meme on Solana."
    />
    <link rel="icon" href="catnobg.png" type="image/png" />
    <meta property="og:title" content="$ok ‚Äî The ok Crying Cat üòøüëç" />
    <meta
      property="og:description"
      content="The Internet's emotional punctuation. Copy the CA and deploy feelings in your chats."
    />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="$ok" />
    <meta property="og:image" content="/og.png" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content="$ok ‚Äî The ok Crying Cat banner" />
    <meta property="og:locale" content="en_US" />
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="$ok ‚Äî The ok Crying Cat üòøüëç" />
    <meta
      name="twitter:description"
      content="The Internet's emotional punctuation. Copy the CA and deploy feelings in your chats."
    />
    <meta name="twitter:image" content="/og.png" />
    <meta name="twitter:image:alt" content="$ok ‚Äî The ok Crying Cat banner" />

    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fun fonts: Comic Neue as a friendly stand-in for Comic Sans -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Anton&family=Comic+Neue:wght@700&family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              funny: ['"Comic Neue"', '"Comic Sans MS"', "cursive"],
              sans: ["Inter", "system-ui", "sans-serif"],
            },
            boxShadow: {
              pop: "0 10px 25px -5px rgba(16, 185, 129, 0.35), 0 8px 10px -6px rgba(16, 185, 129, 0.3)",
            },
          },
        },
      };
    </script>
    <!-- JSZip for client-side ZIP creation -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
      integrity="sha512-hf3Gf9KpF1tA3pQhI2YxQwCGlV6UjzQQLdS6w1qkR2rV3ELdMnaM6lDqBq1BZeg45frQvYiuNfGwxzJEdC5eWw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <style>
      /* Satisfying pop animation for the Copy button */
      @keyframes ok-pop {
        0% {
          transform: scale(1);
        }
        40% {
          transform: scale(1.06);
        }
        60% {
          transform: scale(0.98);
        }
        100% {
          transform: scale(1);
        }
      }
      .animate-ok-pop {
        animation: ok-pop 300ms ease-in-out;
      }

      /* Wiggle and shimmer for playful vibes */
      @keyframes ok-wiggle {
        0%,
        100% {
          transform: rotate(0deg);
        }
        25% {
          transform: rotate(1.2deg);
        }
        50% {
          transform: rotate(-1.2deg);
        }
        75% {
          transform: rotate(0.6deg);
        }
      }
      .hover-wiggle:hover {
        animation: ok-wiggle 350ms ease-in-out;
      }

      /* Emoji burst */
      @keyframes emoji-rise {
        0% {
          transform: translate(-50%, 10px);
          opacity: 0;
        }
        30% {
          opacity: var(--fade, 0.8);
        }
        100% {
          transform: translate(calc(-50% + var(--drift, 0px)), -60px);
          opacity: 0;
        }
      }
      .emoji-burst .emoji {
        animation: emoji-rise 1000ms ease-out;
      }
      /* Localized cat confetti over canvas: radial spread */
      @keyframes cat-confetti {
        0% {
          transform: translate(-50%, -50%) scale(0.85) rotate(0deg);
          opacity: var(--startOpacity, 0.9);
        }
        100% {
          transform: translate(
              calc(-50% + var(--dx, 0px)),
              calc(-50% + var(--dy, 0px))
            )
            scale(1) rotate(var(--rot, 0deg));
          opacity: 0;
        }
      }
      .emoji-burst-local .emoji {
        animation: cat-confetti var(--dur, 900ms) ease-out;
      }
      /* Subtle page background accent */
      body {
        background-image: radial-gradient(
          circle at 50% -20%,
          #fafafa 0%,
          #ffffff 60%
        );
      }

      /* Shimmer gradient text for the $OK heading */
      .shimmer-text {
        background-image: linear-gradient(90deg, #111 0%, #444 50%, #111 100%);
        background-size: 200% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: bg-shimmer 4s ease-in-out infinite;
      }
      @keyframes bg-shimmer {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      /* Gentle floating for hero image card */
      .float-slow {
        animation: float-slow 5s ease-in-out infinite;
      }
      @keyframes float-slow {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-6px);
        }
      }
      .tilt-hover:hover {
        transform: perspective(800px) rotateX(0.6deg) rotateY(-0.6deg);
        transition: transform 200ms ease;
      }

      /* Scroll reveal */
      .reveal {
        opacity: 0;
        transform: translateY(14px);
        transition: opacity 600ms ease, transform 600ms ease;
      }
      .reveal-visible {
        opacity: 1;
        transform: translateY(0);
      }

      /* Soft pulse for primary CTA */
      @keyframes pulse-soft {
        0%,
        100% {
          box-shadow: 0 0 0 rgba(16, 185, 129, 0);
        }
        50% {
          box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.1);
        }
      }
      .pulse-soft {
        animation: pulse-soft 4s ease-in-out infinite;
      }
      /* Background floating cats */
      .cat-float {
        position: absolute;
        top: 0;
        left: 0;
        width: var(--size, 160px);
        height: auto;
        opacity: 0.5; /* 50% as requested */
        filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.1));
        will-change: transform;
        transform: translate(var(--fromX), var(--fromY));
        animation: cat-drift var(--dur, 18s) linear forwards;
      }
      @keyframes cat-drift {
        from {
          transform: translate(var(--fromX), var(--fromY))
            rotate(var(--fromR, 0deg));
        }
        to {
          transform: translate(var(--toX), var(--toY)) rotate(var(--toR, 0deg));
        }
      }
      /* Minimal full-screen lightbox for memes */
      .lightbox-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }
      .lightbox-overlay.show {
        display: flex;
      }
      .lightbox-image {
        max-width: 90vw;
        max-height: 90vh;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      .lightbox-nav,
      .lightbox-close {
        position: absolute;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
        border-radius: 9999px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        background: rgba(255, 255, 255, 0.12);
        color: #000;
        backdrop-filter: blur(6px);
        cursor: pointer;
        font-size: 26px;
        line-height: 1;
      }
      .lightbox-nav.left {
        left: 24px;
        top: 50%;
        transform: translateY(-50%);
      }
      .lightbox-nav.right {
        right: 24px;
        top: 50%;
        transform: translateY(-50%);
      }
      .lightbox-close {
        top: 20px;
        right: 20px;
        font-size: 24px;
      }
      .lightbox-nav:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body class="bg-white text-gray-900 font-sans">
    <!-- Floating background cats layer -->
    <div id="bg-floats" class="fixed inset-0 pointer-events-none z-0"></div>
    <!-- Page wrapper -->
    <main class="min-h-screen relative z-10">
      <!-- NAV (kept minimal, meme-first) -->
      <!-- <header class="border-b border-gray-100">
        <div
          class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between"
        >
          <div class="flex items-center gap-3">
            <span class="text-2xl font-black font-funny">$ok</span>
            <span class="text-sm text-gray-500">The ok Crying Cat üòøüëç</span>
          </div>
          <div class="hidden sm:flex items-center gap-3 text-sm">
            <a href="#vault" class="text-gray-600 hover:text-gray-900">Vault</a>
            <a href="#thesis" class="text-gray-600 hover:text-gray-900"
              >Thesis</a
            >
          </div>
        </div>
      </header> -->

      <!-- HERO SECTION -->
      <section class="max-w-6xl mx-auto px-4 py-12 sm:py-16">
        <div class="text-center">
          <h1
            class="font-funny font-black text-6xl sm:text-8xl md:text-9xl tracking-tight shimmer-text reveal"
          >
            $ok
          </h1>

          <!-- Hero CTAs: Meme Maker + PFP Maker -->
          <div class="mt-6 reveal flex items-center justify-center gap-3">
            <a
              href="#maker"
              id="hero-maker-btn"
              class="inline-flex items-center justify-center rounded-2xl px-5 py-4 text-base sm:text-lg font-semibold bg-black text-white shadow-lg shadow-gray-200 hover:bg-gray-900 transition-all duration-200 hover:scale-[1.02] hover-wiggle"
            >
              ok Meme Maker
            </a>
            <a
              href="/pfp-maker"
              id="hero-pfp-maker-btn"
              class="inline-flex items-center justify-center rounded-2xl px-5 py-4 text-base sm:text-lg font-semibold bg-emerald-500 text-white shadow-lg shadow-emerald-200 hover:bg-emerald-600 transition-all duration-200 hover:scale-[1.02] hover-wiggle"
            >
              ok pfp maker
            </a>
            <a
              href="#pfp"
              id="hero-pfp-btn"
              class="inline-flex items-center justify-center rounded-2xl px-5 py-4 text-base sm:text-lg font-semibold bg-white text-gray-900 border border-gray-200 shadow-lg shadow-gray-200 hover:bg-gray-100 transition-all duration-200 hover:scale-[1.02] hover-wiggle"
            >
              ok-fy my photo
            </a>
          </div>

          <!-- Contract address + Copy CTA (moved here instead of badges) -->
          <div
            class="mt-6 flex flex-col sm:flex-row items-stretch sm:items-center gap-4 reveal"
          >
            <div
              class="flex-1 bg-gray-50 border border-gray-200 rounded-2xl p-4 sm:p-5"
            >
              <div class="text-xs uppercase tracking-widest text-gray-500">
                Contract Address
              </div>
              <div
                id="ca-text"
                class="mt-2 font-mono text-base sm:text-lg md:text-xl break-all select-all"
              >
                F1h8SDKjX6P3pTNzuJYv1VhrEjbtMh76UZYRwiXjpump
              </div>
            </div>
            <button
              id="copy-btn"
              class="shrink-0 inline-flex items-center justify-center rounded-2xl px-5 py-4 text-base sm:text-lg font-semibold bg-emerald-500 text-white shadow-lg shadow-emerald-200 hover:bg-emerald-600 active:bg-emerald-700 transition-all duration-200 hover:scale-[1.02] pulse-soft hover-wiggle"
              aria-live="polite"
            >
              Copy CA üìã
            </button>
          </div>
          <p class="mt-2 text-xs text-gray-500">
            Tap to copy ‚Äî deploy the cat in your chats. üòøüëç (We only do
            emotions.)
          </p>
        </div>

        <!-- Main image placeholder -->
        <div class="mt-10">
          <div
            class="relative overflow-hidden rounded-2xl border border-gray-200 bg-gray-50 float-slow tilt-hover reveal"
          >
            <div class="aspect-[16/9]">
              <img
                src="banner.png"
                alt="Thumbs Up Crying Cat $ok banner"
                class="w-full h-full object-cover"
                loading="lazy"
              />
            </div>
          </div>
        </div>

        <!-- Contract address section moved above; removed here to avoid duplication -->
      </section>

      <!-- THESIS SECTION -->
      <section
        id="thesis"
        class="max-w-6xl mx-auto px-4 py-12 sm:py-16 border-t border-gray-100"
      >
        <h2 class="font-funny text-3xl sm:text-4xl font-black">
          The Thesis (Why We Are Tier-1)
        </h2>
        <div class="mt-6 grid sm:grid-cols-3 gap-6">
          <div class="p-5 border border-gray-200 rounded-2xl bg-white reveal">
            <div class="font-semibold text-lg">High Persistence üòº</div>
            <p class="mt-2 text-gray-700">
              Unlike your ex, we stick around. Not a one-week trend ‚Äî re-used
              across months, years, and every group chat meltdown.
            </p>
          </div>
          <div class="p-5 border border-gray-200 rounded-2xl bg-white reveal">
            <div class="font-semibold text-lg">Infinite Utility ‚ôæÔ∏è</div>
            <p class="mt-2 text-gray-700">
              Tier-1 reaction meme. Instantly readable emotion. Use for wins,
              losses, cope, and "it‚Äôs fine" denial arcs.
            </p>
          </div>
          <div class="p-5 border border-gray-200 rounded-2xl bg-white reveal">
            <div class="font-semibold text-lg">The Strategy üß™</div>
            <p class="mt-2 text-gray-700">
              It's not about the token; it's about deploying the cat as
              emotional punctuation in every chat on earth. Feel first.
              Speculate never (ok sometimes). üëç
            </p>
          </div>
        </div>
      </section>

      <!-- VAULT / GALLERY -->
      <section
        id="vault"
        class="max-w-6xl mx-auto px-4 py-12 sm:py-16 border-t border-gray-100"
      >
        <h2 class="font-funny text-3xl sm:text-4xl font-black">
          The Vault of Coping
        </h2>

        <div
          id="meme-grid"
          class="mt-6 grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4"
        >
          <!-- Populated dynamically by JavaScript -->
        </div>

        <div class="mt-8 flex justify-center">
          <button
            id="download-all"
            class="rounded-2xl px-5 py-4 text-base sm:text-lg font-semibold bg-black text-white hover:bg-gray-800 active:bg-gray-900 transition-colors hover-wiggle"
          >
            Download All (For Twitter arguments & life coping)
          </button>
        </div>
      </section>

      <!-- MEME MAKER -->
      <section
        id="maker"
        class="max-w-6xl mx-auto px-4 py-12 sm:py-16 border-t border-gray-100"
      >
        <h2 class="font-funny text-3xl sm:text-4xl font-black">
          ok Meme Maker
        </h2>
        <p class="mt-2 text-gray-600 text-sm">
          Drop a pic, slap on the ok Cat, then drag, rotate, flip. Copy to
          clipboard or download. üòøüëç
        </p>

        <div class="mt-6 grid lg:grid-cols-2 gap-6">
          <!-- Canvas area -->
          <div class="rounded-2xl border border-gray-200 bg-gray-50 p-3 reveal">
            <div
              class="aspect-square rounded-xl overflow-hidden bg-white flex items-center justify-center"
            >
              <canvas id="meme-canvas" class="w-full h-full"></canvas>
            </div>
          </div>

          <!-- Controls -->
          <div class="rounded-2xl border border-gray-200 bg-white p-4 reveal">
            <div class="flex flex-col gap-3">
              <div id="text-edit-section" class="hidden">
                <div class="text-sm text-gray-600 mt-3">Edit text:</div>
                <div
                  class="mt-2 grid grid-cols-1 sm:grid-cols-4 gap-3 items-end"
                >
                  <label class="block">
                    <span class="text-xs text-gray-600">Size</span>
                    <input
                      id="text-size"
                      type="range"
                      min="20"
                      max="200"
                      step="2"
                      class="w-full"
                    />
                  </label>
                  <label class="block">
                    <span class="text-xs text-gray-600">Color</span>
                    <input
                      id="text-color"
                      type="color"
                      value="#ffffff"
                      class="h-9 p-0 border border-gray-200 rounded-xl"
                      style="width: 50%"
                    />
                  </label>
                  <label class="block">
                    <span class="text-xs text-gray-600">Outline</span>
                    <input
                      id="text-outline"
                      type="range"
                      min="0"
                      max="16"
                      step="1"
                      value="6"
                      class="w-full"
                    />
                  </label>
                  <div class="flex justify-end">
                    <button
                      id="delete-text"
                      class="px-3 py-2 rounded-xl bg-red-500 text-white hover:bg-red-600"
                      aria-label="Delete active text"
                      title="Delete active text"
                    >
                      üóëÔ∏è
                    </button>
                  </div>
                </div>
                <div class="mt-2 flex flex-wrap items-center gap-2">
                  <select
                    id="text-font"
                    class="px-3 py-2 rounded-xl border border-gray-200 focus:outline-none focus:ring-2 focus:ring-emerald-300"
                  >
                    <option value="anton">ok Loud</option>
                    <option value="comic-neue">ok Giggles</option>
                  </select>
                </div>
              </div>

              <div id="cat-edit-section" class="hidden">
                <div class="text-sm text-gray-600 mt-4">Edit cat:</div>
                <div class="mt-2 grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <label class="block">
                    <span class="text-sm text-gray-600">Scale</span>
                    <input
                      id="layer-scale"
                      type="range"
                      min="0.2"
                      max="3"
                      step="0.1"
                      class="w-full"
                    />
                  </label>
                  <label class="block">
                    <span class="text-sm text-gray-600">Rotation</span>
                    <input
                      id="layer-rotation"
                      type="range"
                      min="0"
                      max="360"
                      step="1"
                      class="w-full"
                    />
                  </label>
                </div>
                <div class="mt-2 flex items-center gap-3">
                  <button
                    id="flip-h"
                    class="px-3 py-2 rounded-xl bg-gray-100 hover:bg-gray-200"
                  >
                    Flip H
                  </button>
                  <button
                    id="flip-v"
                    class="px-3 py-2 rounded-xl bg-gray-100 hover:bg-gray-200"
                  >
                    Flip V
                  </button>
                  <button
                    id="delete-layer"
                    class="px-3 py-2 rounded-xl bg-red-500 text-white hover:bg-red-600"
                  >
                    Delete
                  </button>
                </div>
              </div>
              <div>
                <div class="text-sm text-gray-600">Upload base image</div>
                <div class="mt-2 flex items-center gap-3">
                  <input
                    id="meme-file"
                    type="file"
                    accept="image/*"
                    class="hidden"
                  />
                  <button
                    id="meme-upload"
                    class="px-4 py-2 rounded-xl bg-emerald-500 text-white font-semibold hover:bg-emerald-600 hover-wiggle"
                  >
                    Choose Image
                  </button>
                  <button
                    id="meme-use-template"
                    class="px-4 py-2 rounded-xl bg-gray-200 text-gray-900 font-semibold hover:bg-gray-300"
                  >
                    Use template
                  </button>
                  <button
                    id="meme-add-cat"
                    class="px-4 py-2 rounded-xl bg-black text-white font-semibold hover:bg-gray-800"
                  >
                    Add ok Cat
                  </button>
                </div>
              </div>
              <div id="add-text-section" class="mt-4">
                <div class="text-sm text-gray-600">Add text caption</div>
                <div class="mt-2 grid grid-cols-1 sm:grid-cols-2 gap-3">
                  <input
                    id="text-content"
                    type="text"
                    placeholder="Type your caption"
                    class="px-3 py-2 rounded-xl border border-gray-200 focus:outline-none focus:ring-2 focus:ring-emerald-300"
                  />
                  <button
                    id="add-text"
                    class="px-4 py-2 rounded-xl bg-black text-white font-semibold hover:bg-gray-800"
                  >
                    Add Text
                  </button>
                </div>
              </div>

              <div class="mt-3">
                <button
                  id="copy-meme"
                  class="w-full px-5 py-4 rounded-2xl bg-emerald-500 text-white font-semibold hover:bg-emerald-600 hover-wiggle"
                >
                  Copy to Clipboard
                </button>
                <button
                  id="download-meme"
                  class="mt-2 w-full px-5 py-4 rounded-2xl bg-black text-white font-semibold hover:bg-gray-800 hover-wiggle hidden"
                >
                  Download Meme
                </button>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- OK PFP MAKER (moved below Meme Maker) -->
      <section
        id="pfp"
        class="max-w-6xl mx-auto px-4 py-12 sm:py-16 border-t border-gray-100"
      >
        <h2 class="font-funny text-3xl sm:text-4xl font-black">ok-fy photo</h2>
        <p class="mt-2 text-gray-600 text-sm">
          Upload your profile photo and ok-fy it.
        </p>

        <div class="mt-6 grid lg:grid-cols-2 gap-6">
          <!-- Canvas area -->
          <div class="rounded-2xl border border-gray-200 bg-gray-50 p-3 reveal">
            <div class="aspect-square flex items-center justify-center">
              <canvas id="pfp-canvas" class="w-full h-full"></canvas>
            </div>
          </div>

          <!-- Controls -->
          <div class="rounded-2xl border border-gray-200 bg-white p-5 reveal">
            <div>
              <div class="text-sm text-gray-600">Upload profile photo</div>
              <div class="mt-2 flex items-center gap-3">
                <input
                  id="pfp-file"
                  type="file"
                  accept="image/*"
                  class="hidden"
                />
                <button
                  id="pfp-upload"
                  class="px-4 py-2 rounded-xl bg-emerald-500 text-white font-semibold hover:bg-emerald-600 hover-wiggle"
                >
                  Choose Image
                </button>
              </div>
            </div>
            <div class="mt-4">
              <!-- Action area: show ok-fy after upload, then swap to download after ok-fy -->
              <button
                id="pfp-okfy"
                class="hidden w-full px-5 py-4 rounded-2xl bg-black text-white font-semibold hover:bg-gray-800 hover-wiggle"
              >
                ok-fy my pfp
              </button>
              <button
                id="pfp-download"
                class="hidden w-full mt-2 px-5 py-4 rounded-2xl bg-black text-white font-semibold hover:bg-gray-800 hover-wiggle"
              >
                Download
              </button>
            </div>
          </div>
        </div>
      </section>

      <!-- FOOTER -->
      <footer class="border-t border-gray-100">
        <div class="max-w-6xl mx-auto px-4 py-10">
          <div
            class="flex flex-col sm:flex-row items-center justify-between gap-4"
          >
            <div class="flex items-center gap-4">
              <a
                href="https://x.com/okcryingcat"
                class="text-gray-700 hover:text-black font-semibold"
                >X (Twitter)</a
              >
              <span class="text-gray-300">‚Ä¢</span>
              <a
                href="https://x.com/i/communities/2000438470347747829"
                class="text-gray-700 hover:text-black font-semibold"
                >Community</a
              >
              <span class="text-gray-300">‚Ä¢</span>
              <a
                href="https://knowyourmeme.com/memes/thumbs-up-crying-cat"
                target="_blank"
                rel="noopener noreferrer"
                class="text-gray-700 hover:text-black font-semibold"
                aria-label="KnowYourMeme page: Thumbs Up Crying Cat"
              >
                KnowYourMeme
              </a>
            </div>
            <div class="text-xs text-gray-500">
              ¬© 2025 $ok. We are literally just a cat giving a thumbs up. NFA.
              DYOR on feelings.
            </div>
          </div>
        </div>
      </footer>
    </main>

    <!-- Scripts -->
    <script>
      // Copy-to-clipboard with satisfying animation and status updates
      const copyBtn = document.getElementById("copy-btn");
      const caText = document.getElementById("ca-text");
      const originalBtnText = copyBtn.textContent;

      async function copyCA() {
        const text = caText.textContent.trim();
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            // Fallback: create a temporary textarea
            const t = document.createElement("textarea");
            t.value = text;
            document.body.appendChild(t);
            t.select();
            document.execCommand("copy");
            document.body.removeChild(t);
          }

          // Visual feedback
          copyBtn.textContent = "Copied! üòøüëç";
          copyBtn.classList.add("animate-ok-pop");
          copyBtn.classList.add("ring-2", "ring-emerald-300", "shadow-pop");

          // Emoji burst confetti
          burstEmojis(["üòø", "üëç", "üí¨", "‚ú®"]);

          // Revert after a moment
          setTimeout(() => {
            copyBtn.textContent = originalBtnText;
            copyBtn.classList.remove("animate-ok-pop");
            copyBtn.classList.remove(
              "ring-2",
              "ring-emerald-300",
              "shadow-pop"
            );
          }, 1200);
        } catch (err) {
          console.error("Copy failed:", err);
          copyBtn.textContent = "Something broke üòø";
          setTimeout(() => (copyBtn.textContent = originalBtnText), 1500);
        }
      }

      copyBtn.addEventListener("click", copyCA);

      // Utility: ensure JSZip is available (load on demand)
      function loadJSZip() {
        return new Promise((resolve, reject) => {
          if (window.JSZip) return resolve();
          const add = (src) =>
            new Promise((res, rej) => {
              const s = document.createElement("script");
              s.src = src;
              s.crossOrigin = "anonymous";
              s.referrerPolicy = "no-referrer";
              s.onload = () => res();
              s.onerror = () => rej(new Error("Failed to load " + src));
              document.head.appendChild(s);
            });
          add(
            "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
          )
            .then(resolve)
            .catch(() =>
              add("https://unpkg.com/jszip@3.10.1/dist/jszip.min.js")
                .then(resolve)
                .catch(reject)
            );
        });
      }

      // Populate meme grid dynamically from /memes/1.(png|jpeg)..N
      (function populateMemeGrid() {
        const grid = document.getElementById("meme-grid");
        if (!grid) return;
        const maxCount = 126; // Total images available (mixed PNG/JPEG)
        for (let i = 1; i <= maxCount; i++) {
          const card = document.createElement("div");
          card.className =
            "group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal";
          const img = document.createElement("img");
          img.alt = `$ok meme ${i}`;
          img.className = "w-full h-full object-cover";
          img.loading = "lazy";
          // Try PNG then JPEG; remove card if both missing
          const exts = ["png", "jpeg"];
          let tryIndex = 0;
          const tryLoad = () => {
            if (tryIndex >= exts.length) {
              card.remove();
              return;
            }
            img.src = `memes/${i}.${exts[tryIndex]}`;
            tryIndex++;
          };
          img.onerror = tryLoad;
          tryLoad();
          card.appendChild(img);
          grid.appendChild(card);
        }
      })();

      // Minimal full-screen lightbox for meme images
      (function memeLightbox() {
        const grid = document.getElementById("meme-grid");
        if (!grid) return;
        let overlay = null;
        let imageEl = null;
        let prevBtn = null;
        let nextBtn = null;
        let closeBtn = null;
        let currentIndex = -1;

        function buildOverlay() {
          overlay = document.createElement("div");
          overlay.className = "lightbox-overlay";

          imageEl = document.createElement("img");
          imageEl.className = "lightbox-image";
          overlay.appendChild(imageEl);

          prevBtn = document.createElement("button");
          prevBtn.className = "lightbox-nav left";
          prevBtn.textContent = "‚Äπ";
          overlay.appendChild(prevBtn);

          nextBtn = document.createElement("button");
          nextBtn.className = "lightbox-nav right";
          nextBtn.textContent = "‚Ä∫";
          overlay.appendChild(nextBtn);

          closeBtn = document.createElement("button");
          closeBtn.className = "lightbox-close";
          closeBtn.textContent = "√ó";
          overlay.appendChild(closeBtn);

          document.body.appendChild(overlay);

          prevBtn.addEventListener("click", () => navigate(-1));
          nextBtn.addEventListener("click", () => navigate(1));
          closeBtn.addEventListener("click", close);
          overlay.addEventListener("click", (e) => {
            if (e.target === overlay) close();
          });

          document.addEventListener("keydown", (e) => {
            if (!overlay.classList.contains("show")) return;
            if (e.key === "Escape") close();
            else if (e.key === "ArrowLeft") navigate(-1);
            else if (e.key === "ArrowRight") navigate(1);
          });
        }

        function openAt(index) {
          const imgs = Array.from(grid.querySelectorAll("img"));
          if (index < 0 || index >= imgs.length) return;
          currentIndex = index;
          if (!overlay) buildOverlay();
          imageEl.src = imgs[currentIndex].src;
          overlay.classList.add("show");
          updateNavState(imgs.length);
        }

        function updateNavState(len) {
          if (!prevBtn || !nextBtn) return;
          prevBtn.disabled = currentIndex <= 0;
          nextBtn.disabled = currentIndex >= len - 1;
        }

        function navigate(delta) {
          const imgs = Array.from(grid.querySelectorAll("img"));
          const nextIdx = currentIndex + delta;
          if (nextIdx < 0 || nextIdx >= imgs.length) return;
          currentIndex = nextIdx;
          imageEl.src = imgs[currentIndex].src;
          updateNavState(imgs.length);
        }

        function close() {
          if (!overlay) return;
          overlay.classList.remove("show");
        }

        grid.addEventListener("click", (e) => {
          const img = e.target.closest("img");
          if (!img) return;
          const imgs = Array.from(grid.querySelectorAll("img"));
          const idx = imgs.indexOf(img);
          openAt(idx);
        });
      })();

      // Download All: fetch memes/1.(png|jpeg)..N (skip missing) and zip to ok.zip
      document
        .getElementById("download-all")
        .addEventListener("click", async () => {
          const btn = document.getElementById("download-all");
          const original = btn.textContent;
          btn.disabled = true;
          btn.textContent = "Preparing ZIP‚Ä¶";
          try {
            await loadJSZip();
            const zip = new JSZip();
            const folder = zip.folder("ok");
            const MAX = 126;
            const exts = ["png", "jpeg"];
            const buffers = [];
            // For each index, try PNG then JPEG; add whichever exists
            for (let i = 1; i <= MAX; i++) {
              let found = false;
              for (const ext of exts) {
                const path = `memes/${i}.${ext}`;
                try {
                  const res = await fetch(path);
                  if (!res.ok) continue;
                  const buf = await res.arrayBuffer();
                  buffers.push({ name: `${i}.${ext}`, buf });
                  found = true;
                  break;
                } catch (_) {
                  // skip and try next extension
                }
              }
              // if neither PNG nor JPEG found, skip index
              if (!found) continue;
            }

            // Add to zip under ok/
            for (const { name, buf } of buffers) {
              folder.file(name, buf);
            }

            // Generate ZIP and trigger download
            const blob = await zip.generateAsync({ type: "blob" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "ok.zip";
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            btn.textContent = "Downloaded ok.zip üëç";
            burstEmojis(["üì¶", "üòø", "üëç", "‚ú®"]);
            setTimeout(() => (btn.textContent = original), 1400);
          } catch (e) {
            console.error(e);
            btn.textContent = "Download failed üòø";
            setTimeout(() => (btn.textContent = original), 1600);
          } finally {
            btn.disabled = false;
          }
        });

      // Simple emoji burst confetti
      function burstEmojis(list) {
        const container = document.createElement("div");
        container.style.position = "fixed";
        container.style.left = "0";
        container.style.top = "0";
        container.style.width = "100%";
        container.style.height = "100%";
        container.style.pointerEvents = "none";
        container.className = "emoji-burst";
        document.body.appendChild(container);

        const count = 14;
        for (let i = 0; i < count; i++) {
          const span = document.createElement("span");
          span.textContent = list[Math.floor(Math.random() * list.length)];
          span.style.position = "absolute";
          span.style.left = Math.random() * 100 + "%";
          span.style.top = "50%";
          span.style.fontSize = 16 + Math.random() * 18 + "px";
          span.style.opacity = "0";
          span.style.transform = "translate(-50%, 0)";
          span.className = "emoji";
          container.appendChild(span);

          // random animation duration & horizontal drift via CSS variables
          const drift = Math.random() * 60 - 30 + "px";
          span.style.setProperty("--drift", drift);
          span.style.setProperty(
            "--fade",
            (0.6 + Math.random() * 0.6).toString()
          );
        }

        // remove after animation
        setTimeout(() => {
          document.body.removeChild(container);
        }, 1200);
      }

      // Scroll reveal observer
      const observer = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              entry.target.classList.add("reveal-visible");
              observer.unobserve(entry.target);
            }
          }
        },
        { threshold: 0.12 }
      );

      document
        .querySelectorAll(".reveal")
        .forEach((el) => observer.observe(el));

      // Floating background cats
      const floatContainer = document.getElementById("bg-floats");
      function spawnCatFloat() {
        const img = document.createElement("img");
        img.src = "catnobg.png";
        img.className = "cat-float";

        // Random size: 60px ‚Äì 240px
        const size = Math.floor(60 + Math.random() * 180);
        img.style.setProperty("--size", size + "px");

        // Direction: left-to-right or right-to-left
        const leftToRight = Math.random() < 0.5;
        const fromX = leftToRight ? "-20vw" : "120vw";
        const toX = leftToRight ? "120vw" : "-20vw";

        // Vertical path: random start/end along viewport
        const fromY = Math.floor(Math.random() * 100) + "vh";
        const toY = Math.floor(Math.random() * 100) + "vh";

        // Gentle rotation variance
        const fromR = (Math.random() * 20 - 10).toFixed(1) + "deg";
        const toR = (Math.random() * 20 - 10).toFixed(1) + "deg";

        // Duration: 12s ‚Äì 30s
        const dur = (12 + Math.random() * 18).toFixed(1) + "s";

        img.style.setProperty("--fromX", fromX);
        img.style.setProperty("--toX", toX);
        img.style.setProperty("--fromY", fromY);
        img.style.setProperty("--toY", toY);
        img.style.setProperty("--fromR", fromR);
        img.style.setProperty("--toR", toR);
        img.style.setProperty("--dur", dur);

        floatContainer.appendChild(img);
        img.addEventListener("animationend", () => {
          img.remove();
        });
      }

      function startCatFloats() {
        // Seed a few cats
        for (let i = 0; i < 4; i++) spawnCatFloat();

        // Keep spawning, with a soft cap
        const maxConcurrent = 8;
        function loop() {
          if (floatContainer.childElementCount < maxConcurrent) {
            spawnCatFloat();
          }
          const next = 1500 + Math.random() * 2500; // 1.5s ‚Äì 4s
          setTimeout(loop, next);
        }
        loop();
      }

      // Initialize after page loads
      document.addEventListener("DOMContentLoaded", startCatFloats);

      // Meme Maker logic: canvas rendering and controls
      (function memeMaker() {
        const canvas = document.getElementById("meme-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        // State
        let baseImage = null; // HTMLImageElement
        const layers = []; // overlay layers
        let selectedLayerId = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        // Controls
        const fileInput = document.getElementById("meme-file");
        const uploadBtn = document.getElementById("meme-upload");
        const templateBtn = document.getElementById("meme-use-template");
        const addCatBtn = document.getElementById("meme-add-cat");
        const scaleInput = document.getElementById("layer-scale");
        const rotInput = document.getElementById("layer-rotation");
        const flipHBtn = document.getElementById("flip-h");
        const flipVBtn = document.getElementById("flip-v");
        const delBtn = document.getElementById("delete-layer");
        const copyBtn = document.getElementById("copy-meme");
        const downloadMemeBtn = document.getElementById("download-meme");
        const deleteTextBtn = document.getElementById("delete-text");

        // Viewport-based behavior: prefer download on small screens
        let preferDownload = window.matchMedia("(max-width: 799px)").matches;
        function updateCopyBtnLabel() {
          if (!copyBtn) return;
          copyBtn.textContent = preferDownload
            ? "Download Meme"
            : "Copy to Clipboard";
        }
        function updateDownloadBtnVisibility() {
          if (!downloadMemeBtn) return;
          // Show download button only on desktop (>= 800px)
          if (preferDownload) {
            downloadMemeBtn.classList.add("hidden");
          } else {
            downloadMemeBtn.classList.remove("hidden");
          }
        }
        function refreshExportButtons() {
          // Always update labels/viewport toggles first
          updateCopyBtnLabel();
          // Hide both export buttons if no base image
          if (!baseImage) {
            copyBtn.classList.add("hidden");
            if (downloadMemeBtn) downloadMemeBtn.classList.add("hidden");
            // Also hide creation controls when no base image
            if (addCatBtn) addCatBtn.classList.add("hidden");
            const textEditEl = document.getElementById("text-edit-section");
            if (textEditEl) textEditEl.classList.add("hidden");
            const addTextSection = document.getElementById("add-text-section");
            if (addTextSection) addTextSection.classList.add("hidden");
          } else {
            copyBtn.classList.remove("hidden");
            updateDownloadBtnVisibility();
            // Show add-cat only when base image exists
            if (addCatBtn) addCatBtn.classList.remove("hidden");
            const addTextSection = document.getElementById("add-text-section");
            if (addTextSection) addTextSection.classList.remove("hidden");
          }
        }
        refreshExportButtons();
        const mq = window.matchMedia("(max-width: 799px)");
        // Update on MQ change
        if (mq && mq.addEventListener) {
          mq.addEventListener("change", (e) => {
            preferDownload = e.matches;
            refreshExportButtons();
          });
        }
        // Fallback: update on resize
        window.addEventListener("resize", () => {
          const current = window.innerWidth < 800;
          if (current !== preferDownload) {
            preferDownload = current;
            refreshExportButtons();
          }
        });

        // Text controls
        const textInput = document.getElementById("text-content");
        const textFont = document.getElementById("text-font");
        const textSize = document.getElementById("text-size");
        const textColor = document.getElementById("text-color");
        const textOutline = document.getElementById("text-outline");
        const addTextBtn = document.getElementById("add-text");
        const textEditSection = document.getElementById("text-edit-section");
        const catEditSection = document.getElementById("cat-edit-section");

        // Resize canvas to square container size with devicePixelRatio
        function resizeCanvas() {
          const parent = canvas.parentElement;
          const size = parent.clientWidth; // aspect-square container
          const dpr = window.devicePixelRatio || 1;
          canvas.width = Math.max(1, Math.floor(size * dpr));
          canvas.height = Math.max(1, Math.floor(size * dpr));
          canvas.style.width = size + "px";
          canvas.style.height = size + "px";
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(dpr, dpr);
          draw();
        }
        window.addEventListener("resize", resizeCanvas);
        requestAnimationFrame(resizeCanvas);

        function clearCanvas() {
          const w = canvas.width / (window.devicePixelRatio || 1);
          const h = canvas.height / (window.devicePixelRatio || 1);
          ctx.clearRect(0, 0, w, h);
        }

        function draw() {
          clearCanvas();
          const w = canvas.width / (window.devicePixelRatio || 1);
          const h = canvas.height / (window.devicePixelRatio || 1);
          let fitRect = null;
          // Draw base image fit contain
          if (baseImage) {
            const fit = contain(
              baseImage.naturalWidth,
              baseImage.naturalHeight,
              w,
              h
            );
            ctx.drawImage(baseImage, fit.x, fit.y, fit.width, fit.height);
            fitRect = fit;
            // Clip overlays to the bounds of the base image
            ctx.save();
            ctx.beginPath();
            ctx.rect(fit.x, fit.y, fit.width, fit.height);
            ctx.clip();
          } else {
            // Placeholder background
            ctx.fillStyle = "#f8fafc";
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = "#94a3b8";
            ctx.textAlign = "center";
            ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto";
            ctx.fillText("Upload an image or Add ok Cat", w / 2, h / 2);
          }

          // Draw layers
          for (const layer of layers) {
            if (layer.type === "text") {
              drawTextLayer(layer);
            } else {
              drawImageLayer(layer);
            }
          }

          // Restore clipping if applied
          if (fitRect) {
            ctx.restore();
          }
        }

        function contain(srcW, srcH, maxW, maxH) {
          const ratio = Math.min(maxW / srcW, maxH / srcH);
          const width = srcW * ratio;
          const height = srcH * ratio;
          const x = (maxW - width) / 2;
          const y = (maxH - height) / 2;
          return { x, y, width, height, ratio };
        }

        function drawImageLayer(layer) {
          const imgW = layer.image.naturalWidth * layer.scale;
          const imgH = layer.image.naturalHeight * layer.scale;

          ctx.save();
          ctx.translate(layer.x, layer.y);
          ctx.rotate((layer.rotation * Math.PI) / 180);
          ctx.scale(layer.flipH ? -1 : 1, layer.flipV ? -1 : 1);
          ctx.drawImage(layer.image, -imgW / 2, -imgH / 2, imgW, imgH);
          if (layer.id === selectedLayerId) {
            ctx.strokeStyle = "#10b981";
            ctx.lineWidth = 2;
            ctx.strokeRect(-imgW / 2, -imgH / 2, imgW, imgH);
          }
          ctx.restore();
        }

        function textFamilyFrom(value) {
          return value === "anton"
            ? "Anton, Impact, sans-serif"
            : "'Comic Neue', 'Comic Sans MS', cursive";
        }

        function drawTextLayer(layer) {
          const w = canvas.width / (window.devicePixelRatio || 1);
          const h = canvas.height / (window.devicePixelRatio || 1);
          const text = layer.text;
          ctx.save();
          ctx.translate(layer.x, layer.y);
          ctx.rotate((layer.rotation * Math.PI) / 180);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `${layer.weight} ${Math.max(
            8,
            layer.fontSize
          )}px ${textFamilyFrom(layer.font)}`;
          ctx.lineJoin = "round";
          if (layer.strokeWidth > 0) {
            ctx.strokeStyle = layer.stroke;
            ctx.lineWidth = layer.strokeWidth;
            ctx.strokeText(text, 0, 0);
          }
          ctx.fillStyle = layer.fill;
          ctx.fillText(text, 0, 0);
          if (layer.id === selectedLayerId) {
            // selection guide box
            const m = ctx.measureText(text);
            const tw = m.width;
            const th = layer.fontSize * 1.2;
            ctx.strokeStyle = "#10b981";
            ctx.lineWidth = 2;
            ctx.strokeRect(-tw / 2, -th / 2, tw, th);
          }
          ctx.restore();
        }

        function createCatLayer() {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              const w = canvas.width / (window.devicePixelRatio || 1);
              const h = canvas.height / (window.devicePixelRatio || 1);
              const size = Math.min(w, h) * 0.4;
              const scale = size / img.naturalWidth;
              const layer = {
                id: "layer-" + Math.random().toString(36).slice(2),
                image: img,
                x: w / 2,
                y: h / 2,
                scale,
                rotation: 0,
                flipH: false,
                flipV: false,
              };
              resolve(layer);
            };
            img.onerror = reject;
            img.src = "catnobg.png";
          });
        }

        function selectLayerByPoint(px, py) {
          // Check from topmost to bottom for point-in-rotated-rect
          for (let i = layers.length - 1; i >= 0; i--) {
            const layer = layers[i];
            const dx = px - layer.x;
            const dy = py - layer.y;
            const rad = (-layer.rotation * Math.PI) / 180;
            const cos = Math.cos(rad),
              sin = Math.sin(rad);
            const lx = dx * cos - dy * sin;
            const ly = dx * sin + dy * cos;
            let bw = 0,
              bh = 0;
            if (layer.type === "text") {
              ctx.save();
              ctx.font = `${layer.weight} ${Math.max(
                8,
                layer.fontSize
              )}px ${textFamilyFrom(layer.font)}`;
              const m = ctx.measureText(layer.text);
              ctx.restore();
              bw = m.width;
              bh = layer.fontSize * 1.2;
            } else {
              bw = layer.image.naturalWidth * layer.scale;
              bh = layer.image.naturalHeight * layer.scale;
            }
            if (Math.abs(lx) <= bw / 2 && Math.abs(ly) <= bh / 2) {
              selectedLayerId = layer.id;
              if (layer.type !== "text") {
                scaleInput.value = String(layer.scale);
              }
              rotInput.value = String(layer.rotation);
              // Reflect text layer values into UI
              if (layer.type === "text") {
                textInput.value = layer.text;
                textFont.value = layer.font;
                textSize.value = String(layer.fontSize);
                textColor.value = layer.fill;
                textOutline.value = String(layer.strokeWidth);
              }
              // Toggle edit sections visibility
              if (textEditSection) {
                textEditSection.classList.toggle(
                  "hidden",
                  layer.type !== "text"
                );
              }
              if (catEditSection) {
                catEditSection.classList.toggle(
                  "hidden",
                  layer.type !== "image"
                );
              }
              return layer;
            }
          }
          // If no layer hit, clear selection and hide sections
          selectedLayerId = null;
          if (textEditSection) textEditSection.classList.add("hidden");
          if (catEditSection) catEditSection.classList.add("hidden");
          return null;
        }

        // Events
        uploadBtn.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", () => {
          const file = fileInput.files?.[0];
          if (!file) return;
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            baseImage = img;
            URL.revokeObjectURL(url);
            draw();
            refreshExportButtons();
          };
          img.src = url;
        });

        // Use template.png as base image
        if (templateBtn) {
          templateBtn.addEventListener("click", () => {
            const img = new Image();
            img.onload = () => {
              baseImage = img;
              draw();
              refreshExportButtons();
            };
            img.src = "template.png";
          });
        }

        addCatBtn.addEventListener("click", async () => {
          if (!baseImage) return;
          try {
            const layer = await createCatLayer();
            layer.type = "image";
            layers.push(layer);
            selectedLayerId = layer.id;
            scaleInput.value = String(layer.scale);
            rotInput.value = String(layer.rotation);
            if (textEditSection) textEditSection.classList.add("hidden");
            if (catEditSection) catEditSection.classList.remove("hidden");
            draw();
          } catch (e) {
            alert("Failed to load cat image");
          }
        });

        scaleInput.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.scale = parseFloat(scaleInput.value);
          draw();
        });
        rotInput.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.rotation = parseFloat(rotInput.value);
          draw();
        });

        flipHBtn.addEventListener("click", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.flipH = !layer.flipH;
          draw();
        });
        flipVBtn.addEventListener("click", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.flipV = !layer.flipV;
          draw();
        });
        delBtn.addEventListener("click", () => {
          const idx = layers.findIndex((l) => l.id === selectedLayerId);
          if (idx >= 0) {
            layers.splice(idx, 1);
            selectedLayerId = null;
            draw();
          }
        });

        // Delete active text via text edit row button
        if (deleteTextBtn) {
          deleteTextBtn.addEventListener("click", () => {
            const idx = layers.findIndex((l) => l.id === selectedLayerId);
            if (idx >= 0 && layers[idx].type === "text") {
              layers.splice(idx, 1);
              selectedLayerId = null;
              // Hide the text edit section when no active text
              if (textEditSection) textEditSection.classList.add("hidden");
              draw();
            }
          });
        }

        // Text layer creation helpers
        function createTextLayerAt(yPos) {
          const w = canvas.width / (window.devicePixelRatio || 1);
          const h = canvas.height / (window.devicePixelRatio || 1);
          const font = textFont.value || "anton";
          const layer = {
            id: "layer-" + Math.random().toString(36).slice(2),
            type: "text",
            text: (textInput.value || "ok").trim(),
            font,
            weight: font === "anton" ? "700" : "700",
            fontSize: parseInt(textSize.value || "72", 10),
            fill: textColor.value || "#ffffff",
            stroke: "#000000",
            strokeWidth: parseInt(textOutline.value || "6", 10),
            x: w / 2,
            y: yPos ?? h / 2,
            rotation: 0,
            flipH: false,
            flipV: false,
          };
          return layer;
        }

        function addTextCommon(yPos) {
          const layer = createTextLayerAt(yPos);
          layers.push(layer);
          selectedLayerId = layer.id;
          rotInput.value = String(layer.rotation);
          if (catEditSection) catEditSection.classList.add("hidden");
          if (textEditSection) textEditSection.classList.remove("hidden");
          draw();
        }

        addTextBtn.addEventListener("click", () => {
          if (!baseImage) return;
          addTextCommon();
        });
        // Live update: size, color, outline, font
        textSize.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.fontSize = parseInt(
            textSize.value || String(layer.fontSize),
            10
          );
          draw();
        });
        textColor.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.fill = textColor.value || layer.fill;
          draw();
        });
        textOutline.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.strokeWidth = parseInt(
            textOutline.value || String(layer.strokeWidth),
            10
          );
          draw();
        });
        textFont.addEventListener("change", async () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.font = textFont.value || layer.font;
          if (document.fonts && document.fonts.ready) {
            try {
              await document.fonts.ready;
            } catch {}
          }
          draw();
        });
        // Optional: live text content editing
        textInput.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.text = (textInput.value || "").trim();
          draw();
        });

        // Pointer dragging
        function canvasPoint(evt) {
          const rect = canvas.getBoundingClientRect();
          const x = evt.clientX - rect.left;
          const y = evt.clientY - rect.top;
          return { x, y };
        }
        canvas.addEventListener("mousedown", (evt) => {
          const { x, y } = canvasPoint(evt);
          const layer = selectLayerByPoint(x, y);
          if (layer) {
            isDragging = true;
            dragOffset.x = x - layer.x;
            dragOffset.y = y - layer.y;
            draw();
          } else {
            // Hide edit sections if clicking empty space
            if (textEditSection) textEditSection.classList.add("hidden");
            if (catEditSection) catEditSection.classList.add("hidden");
            draw();
          }
        });
        window.addEventListener("mousemove", (evt) => {
          if (!isDragging) return;
          const { x, y } = canvasPoint(evt);
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.x = x - dragOffset.x;
          layer.y = y - dragOffset.y;
          draw();
        });
        window.addEventListener("mouseup", () => {
          isDragging = false;
        });

        // Touch dragging
        canvas.addEventListener(
          "touchstart",
          (evt) => {
            const t = evt.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = t.clientX - rect.left;
            const y = t.clientY - rect.top;
            const layer = selectLayerByPoint(x, y);
            if (layer) {
              // Prevent page scroll while initiating a drag on canvas
              evt.preventDefault();
              isDragging = true;
              dragOffset.x = x - layer.x;
              dragOffset.y = y - layer.y;
              // Hint to browsers to disable touch scrolling while active
              canvas.style.touchAction = "none";
              draw();
            }
          },
          { passive: false }
        );
        canvas.addEventListener(
          "touchmove",
          (evt) => {
            if (!isDragging) return;
            // Prevent page scroll while dragging on canvas
            evt.preventDefault();
            const t = evt.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = t.clientX - rect.left;
            const y = t.clientY - rect.top;
            const layer = layers.find((l) => l.id === selectedLayerId);
            if (!layer) return;
            layer.x = x - dragOffset.x;
            layer.y = y - dragOffset.y;
            draw();
          },
          { passive: false }
        );
        canvas.addEventListener(
          "touchend",
          () => {
            isDragging = false;
            // Restore default touch behavior when not dragging
            canvas.style.touchAction = "";
          },
          { passive: false }
        );

        // Copy to clipboard or download based on viewport preference
        copyBtn.addEventListener("click", async () => {
          if (!baseImage) return; // no image: do nothing
          const dpr = window.devicePixelRatio || 1;
          const w = canvas.width / dpr;
          const h = canvas.height / dpr;

          // Determine export area: if base image exists, export only its fitted region
          let exportW = Math.floor(w);
          let exportH = Math.floor(h);
          let offsetX = 0;
          let offsetY = 0;

          let fit = null;
          if (baseImage) {
            fit = contain(
              baseImage.naturalWidth,
              baseImage.naturalHeight,
              w,
              h
            );
            exportW = Math.floor(fit.width);
            exportH = Math.floor(fit.height);
            offsetX = fit.x;
            offsetY = fit.y;
          }

          const off = document.createElement("canvas");
          off.width = exportW;
          off.height = exportH;
          const octx = off.getContext("2d");

          if (baseImage && fit) {
            // Draw only the fitted base image region
            octx.drawImage(baseImage, 0, 0, fit.width, fit.height);
          } else {
            // No base image; export the full canvas area
            octx.fillStyle = "#ffffff";
            octx.fillRect(0, 0, exportW, exportH);
          }

          // Draw overlays, shifted so (0,0) == top-left of fitted base image
          for (const layer of layers) {
            octx.save();
            const tx = layer.x - offsetX;
            const ty = layer.y - offsetY;
            octx.translate(tx, ty);
            octx.rotate((layer.rotation * Math.PI) / 180);
            octx.scale(layer.flipH ? -1 : 1, layer.flipV ? -1 : 1);
            if (layer.type === "text") {
              const text = layer.text;
              octx.textAlign = "center";
              octx.textBaseline = "middle";
              octx.font = `${layer.weight} ${Math.max(
                8,
                layer.fontSize
              )}px ${textFamilyFrom(layer.font)}`;
              octx.lineJoin = "round";
              if (layer.strokeWidth > 0) {
                octx.strokeStyle = layer.stroke;
                octx.lineWidth = layer.strokeWidth;
                octx.strokeText(text, 0, 0);
              }
              octx.fillStyle = layer.fill;
              octx.fillText(text, 0, 0);
            } else {
              const imgW = layer.image.naturalWidth * layer.scale;
              const imgH = layer.image.naturalHeight * layer.scale;
              octx.drawImage(layer.image, -imgW / 2, -imgH / 2, imgW, imgH);
            }
            octx.restore();
          }

          if (document.fonts && document.fonts.ready) {
            try {
              await document.fonts.ready;
            } catch {}
          }

          try {
            const blob = await new Promise((res) =>
              off.toBlob(res, "image/png")
            );
            if (!blob) throw new Error("Blob unavailable");
            const doCopy =
              !preferDownload && navigator.clipboard && window.ClipboardItem;
            if (doCopy) {
              await navigator.clipboard.write([
                new ClipboardItem({ "image/png": blob }),
              ]);
              const original = copyBtn.textContent;
              copyBtn.textContent = "Copied! üòøüëç";
              burstEmojis(["üòø", "üëç", "‚ú®", "üñºÔ∏è"]);
              setTimeout(() => (copyBtn.textContent = original), 1200);
            } else {
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "ok-meme.png";
              document.body.appendChild(a);
              a.click();
              a.remove();
              URL.revokeObjectURL(url);
              const original = copyBtn.textContent;
              copyBtn.textContent = "Downloaded ok-meme.png";
              burstEmojis(["üì•", "üòø", "üëç", "‚ú®"]);
              setTimeout(() => (copyBtn.textContent = original), 1400);
            }
          } catch (err) {
            alert("Failed to copy/download");
          }
        });

        // Dedicated desktop Download button: always downloads
        if (downloadMemeBtn) {
          downloadMemeBtn.addEventListener("click", async () => {
            if (!baseImage) return; // no image: do nothing
            const dpr = window.devicePixelRatio || 1;
            const w = canvas.width / dpr;
            const h = canvas.height / dpr;

            let exportW = Math.floor(w);
            let exportH = Math.floor(h);
            let offsetX = 0;
            let offsetY = 0;

            let fit = null;
            if (baseImage) {
              fit = contain(
                baseImage.naturalWidth,
                baseImage.naturalHeight,
                w,
                h
              );
              exportW = Math.floor(fit.width);
              exportH = Math.floor(fit.height);
              offsetX = fit.x;
              offsetY = fit.y;
            }

            const off = document.createElement("canvas");
            off.width = exportW;
            off.height = exportH;
            const octx = off.getContext("2d");

            if (baseImage && fit) {
              octx.drawImage(baseImage, 0, 0, fit.width, fit.height);
            } else {
              octx.fillStyle = "#ffffff";
              octx.fillRect(0, 0, exportW, exportH);
            }

            for (const layer of layers) {
              octx.save();
              const tx = layer.x - offsetX;
              const ty = layer.y - offsetY;
              octx.translate(tx, ty);
              octx.rotate((layer.rotation * Math.PI) / 180);
              octx.scale(layer.flipH ? -1 : 1, layer.flipV ? -1 : 1);
              if (layer.type === "text") {
                const text = layer.text;
                octx.textAlign = "center";
                octx.textBaseline = "middle";
                octx.font = `${layer.weight} ${Math.max(
                  8,
                  layer.fontSize
                )}px ${textFamilyFrom(layer.font)}`;
                octx.lineJoin = "round";
                if (layer.strokeWidth > 0) {
                  octx.strokeStyle = layer.stroke;
                  octx.lineWidth = layer.strokeWidth;
                  octx.strokeText(text, 0, 0);
                }
                octx.fillStyle = layer.fill;
                octx.fillText(text, 0, 0);
              } else {
                const imgW = layer.image.naturalWidth * layer.scale;
                const imgH = layer.image.naturalHeight * layer.scale;
                octx.drawImage(layer.image, -imgW / 2, -imgH / 2, imgW, imgH);
              }
              octx.restore();
            }

            if (document.fonts && document.fonts.ready) {
              try {
                await document.fonts.ready;
              } catch {}
            }

            try {
              const blob = await new Promise((res) =>
                off.toBlob(res, "image/png")
              );
              if (!blob) throw new Error("Blob unavailable");
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "ok-meme.png";
              document.body.appendChild(a);
              a.click();
              a.remove();
              URL.revokeObjectURL(url);
              const original = downloadMemeBtn.textContent;
              downloadMemeBtn.textContent = "Downloaded ok-meme.png";
              burstEmojis(["üì•", "üòø", "üëç", "‚ú®"]);
              setTimeout(() => (downloadMemeBtn.textContent = original), 1400);
            } catch (err) {
              alert("Failed to download");
            }
          });
        }
      })();

      // OK PFP Maker logic
      (function pfpMaker() {
        const canvas = document.getElementById("pfp-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        const PFP_SIZE = 1080; // logical preview and export size

        // Controls
        const fileInput = document.getElementById("pfp-file");
        const uploadBtn = document.getElementById("pfp-upload");
        const okfyBtn = document.getElementById("pfp-okfy");
        const downloadBtn = document.getElementById("pfp-download");

        // State
        let baseImage = null; // uploaded pfp
        let catImage = null; // overlay image
        let okfied = false;

        // Load cat image
        const cat = new Image();
        cat.onload = () => {
          catImage = cat;
          draw();
        };
        cat.src = "catnobg.png";

        function dpr() {
          return window.devicePixelRatio || 1;
        }

        function resizeCanvas() {
          const ratio = dpr();
          // Keep a fixed logical size of 1080√ó1080, scale buffer by DPR
          canvas.width = Math.floor(PFP_SIZE * ratio);
          canvas.height = Math.floor(PFP_SIZE * ratio);
          draw();
        }

        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();

        function cover(srcW, srcH, dstW, dstH) {
          const scale = Math.max(dstW / srcW, dstH / srcH);
          const width = srcW * scale;
          const height = srcH * scale;
          const x = (dstW - width) / 2;
          const y = (dstH - height) / 2;
          return { x, y, width, height, scale };
        }

        function draw() {
          const ratio = dpr();
          const w = PFP_SIZE;
          const h = PFP_SIZE;
          ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
          ctx.clearRect(0, 0, w, h);
          ctx.fillStyle = "#f8fafc";
          ctx.fillRect(0, 0, w, h);

          if (baseImage) {
            const fit = cover(
              baseImage.naturalWidth,
              baseImage.naturalHeight,
              w,
              h
            );
            ctx.drawImage(baseImage, fit.x, fit.y, fit.width, fit.height);
          } else {
            ctx.fillStyle = "#94a3b8";
            ctx.textAlign = "center";
            ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto";
            ctx.fillText("Upload a profile photo", w / 2, h / 2);
          }

          if (okfied && catImage) {
            const targetW = Math.floor(w * 0.68);
            const aspect = catImage.naturalHeight / catImage.naturalWidth;
            const targetH = Math.floor(targetW * aspect);
            const x = w - targetW;
            const y = h - targetH;
            ctx.drawImage(catImage, x, y, targetW, targetH);
          }
        }

        // Confetti: small cats
        function burstCats() {
          // Position container directly over the PFP canvas
          const rect = canvas.getBoundingClientRect();
          const container = document.createElement("div");
          container.style.position = "fixed";
          container.style.left = rect.left + "px";
          container.style.top = rect.top + "px";
          container.style.width = rect.width + "px";
          container.style.height = rect.height + "px";
          container.style.pointerEvents = "none";
          container.className = "emoji-burst-local";
          document.body.appendChild(container);

          // More confetti, spread radially in all directions
          const count = 30;
          const maxDist = Math.max(rect.width, rect.height) * 0.6; // travel distance
          for (let i = 0; i < count; i++) {
            const img = document.createElement("img");
            img.src = "catnobg.png";
            img.style.position = "absolute";
            img.style.left = "50%";
            img.style.top = "50%";
            const size = 18 + Math.random() * 26;
            img.style.width = size + "px";
            img.style.height = "auto";
            img.style.opacity = "0";
            img.style.transform = "translate(-50%, -50%)";
            img.className = "emoji";
            container.appendChild(img);

            const angle = Math.random() * Math.PI * 2; // 0..360¬∞
            const dist = maxDist * (0.45 + Math.random() * 0.65);
            const dx = Math.cos(angle) * dist + "px";
            const dy = Math.sin(angle) * dist + "px";
            const rot = (Math.random() * 120 - 60).toFixed(1) + "deg";
            const dur = (800 + Math.random() * 500).toFixed(0) + "ms";
            img.style.setProperty("--dx", dx);
            img.style.setProperty("--dy", dy);
            img.style.setProperty("--rot", rot);
            img.style.setProperty("--dur", dur);
            img.style.setProperty(
              "--startOpacity",
              (0.75 + Math.random() * 0.25).toString()
            );
          }

          setTimeout(() => {
            document.body.removeChild(container);
          }, 1400);
        }

        // Events
        // Initial visibility: show neither okfy nor download
        okfyBtn.classList.add("hidden");
        downloadBtn.classList.add("hidden");

        uploadBtn.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", () => {
          const file = fileInput.files?.[0];
          if (!file) return;
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            baseImage = img;
            okfied = false;
            // After upload: show ok-fy, hide download
            okfyBtn.classList.remove("hidden");
            downloadBtn.classList.add("hidden");
            URL.revokeObjectURL(url);
            draw();
          };
          img.src = url;
        });

        okfyBtn.addEventListener("click", () => {
          if (!baseImage || okfied) return;
          okfied = true;
          burstCats();
          draw();
          // Swap: hide ok-fy, show download
          okfyBtn.classList.add("hidden");
          downloadBtn.classList.remove("hidden");
        });

        downloadBtn.addEventListener("click", async () => {
          const w = PFP_SIZE;
          const h = PFP_SIZE;
          // Render to offscreen at exact 1080√ó1080 output size
          const off = document.createElement("canvas");
          off.width = w;
          off.height = h;
          const octx = off.getContext("2d");
          octx.setTransform(1, 0, 0, 1, 0, 0);

          // Draw base
          if (baseImage) {
            const fit = cover(
              baseImage.naturalWidth,
              baseImage.naturalHeight,
              w,
              h
            );
            octx.drawImage(baseImage, fit.x, fit.y, fit.width, fit.height);
          } else {
            octx.fillStyle = "#ffffff";
            octx.fillRect(0, 0, w, h);
          }

          // Draw cat overlay if okfied
          if (okfied && catImage) {
            const targetW = Math.floor(w * 0.66);
            const aspect = catImage.naturalHeight / catImage.naturalWidth;
            const targetH = Math.floor(targetW * aspect);
            const x = w - targetW;
            const y = h - targetH;
            octx.drawImage(catImage, x, y, targetW, targetH);
          }

          const blob = await new Promise((res) => off.toBlob(res, "image/png"));
          if (!blob) return;
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "ok-pfp.png";
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        });
      })();
    </script>
  </body>
</html>
