<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>$ok ‚Äî The ok Crying Cat</title>
    <meta
      name="description"
      content="$ok ‚Äî The Internet's Emotional Punctuation. A timeless, tier-1 reaction meme on Solana."
    />
    <link rel="icon" href="catnobg.png" type="image/png" />
    <meta property="og:title" content="$ok ‚Äî The ok Crying Cat üòøüëç" />
    <meta
      property="og:description"
      content="The Internet's emotional punctuation. Copy the CA and deploy feelings in your chats."
    />

    <!-- Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fun fonts: Comic Neue as a friendly stand-in for Comic Sans -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Anton&family=Comic+Neue:wght@700&family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              funny: ['"Comic Neue"', '"Comic Sans MS"', "cursive"],
              sans: ["Inter", "system-ui", "sans-serif"],
            },
            boxShadow: {
              pop: "0 10px 25px -5px rgba(16, 185, 129, 0.35), 0 8px 10px -6px rgba(16, 185, 129, 0.3)",
            },
          },
        },
      };
    </script>
    <!-- JSZip for client-side ZIP creation -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
      integrity="sha512-hf3Gf9KpF1tA3pQhI2YxQwCGlV6UjzQQLdS6w1qkR2rV3ELdMnaM6lDqBq1BZeg45frQvYiuNfGwxzJEdC5eWw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <style>
      /* Satisfying pop animation for the Copy button */
      @keyframes ok-pop {
        0% {
          transform: scale(1);
        }
        40% {
          transform: scale(1.06);
        }
        60% {
          transform: scale(0.98);
        }
        100% {
          transform: scale(1);
        }
      }
      .animate-ok-pop {
        animation: ok-pop 300ms ease-in-out;
      }

      /* Wiggle and shimmer for playful vibes */
      @keyframes ok-wiggle {
        0%,
        100% {
          transform: rotate(0deg);
        }
        25% {
          transform: rotate(1.2deg);
        }
        50% {
          transform: rotate(-1.2deg);
        }
        75% {
          transform: rotate(0.6deg);
        }
      }
      .hover-wiggle:hover {
        animation: ok-wiggle 350ms ease-in-out;
      }

      /* Emoji burst */
      @keyframes emoji-rise {
        0% {
          transform: translate(-50%, 10px);
          opacity: 0;
        }
        30% {
          opacity: var(--fade, 0.8);
        }
        100% {
          transform: translate(calc(-50% + var(--drift, 0px)), -60px);
          opacity: 0;
        }
      }
      .emoji-burst .emoji {
        animation: emoji-rise 1000ms ease-out;
      }
      /* Subtle page background accent */
      body {
        background-image: radial-gradient(
          circle at 50% -20%,
          #fafafa 0%,
          #ffffff 60%
        );
      }

      /* Shimmer gradient text for the $OK heading */
      .shimmer-text {
        background-image: linear-gradient(90deg, #111 0%, #444 50%, #111 100%);
        background-size: 200% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        animation: bg-shimmer 4s ease-in-out infinite;
      }
      @keyframes bg-shimmer {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      /* Gentle floating for hero image card */
      .float-slow {
        animation: float-slow 5s ease-in-out infinite;
      }
      @keyframes float-slow {
        0%,
        100% {
          transform: translateY(0);
        }
        50% {
          transform: translateY(-6px);
        }
      }
      .tilt-hover:hover {
        transform: perspective(800px) rotateX(0.6deg) rotateY(-0.6deg);
        transition: transform 200ms ease;
      }

      /* Scroll reveal */
      .reveal {
        opacity: 0;
        transform: translateY(14px);
        transition: opacity 600ms ease, transform 600ms ease;
      }
      .reveal-visible {
        opacity: 1;
        transform: translateY(0);
      }

      /* Soft pulse for primary CTA */
      @keyframes pulse-soft {
        0%,
        100% {
          box-shadow: 0 0 0 rgba(16, 185, 129, 0);
        }
        50% {
          box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.1);
        }
      }
      .pulse-soft {
        animation: pulse-soft 4s ease-in-out infinite;
      }
      /* Background floating cats */
      .cat-float {
        position: absolute;
        top: 0;
        left: 0;
        width: var(--size, 160px);
        height: auto;
        opacity: 0.5; /* 50% as requested */
        filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.1));
        will-change: transform;
        transform: translate(var(--fromX), var(--fromY));
        animation: cat-drift var(--dur, 18s) linear forwards;
      }
      @keyframes cat-drift {
        from {
          transform: translate(var(--fromX), var(--fromY))
            rotate(var(--fromR, 0deg));
        }
        to {
          transform: translate(var(--toX), var(--toY)) rotate(var(--toR, 0deg));
        }
      }
    </style>
  </head>
  <body class="bg-white text-gray-900 font-sans">
    <!-- Floating background cats layer -->
    <div id="bg-floats" class="fixed inset-0 pointer-events-none z-0"></div>
    <!-- Page wrapper -->
    <main class="min-h-screen relative z-10">
      <!-- NAV (kept minimal, meme-first) -->
      <!-- <header class="border-b border-gray-100">
        <div
          class="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between"
        >
          <div class="flex items-center gap-3">
            <span class="text-2xl font-black font-funny">$ok</span>
            <span class="text-sm text-gray-500">The ok Crying Cat üòøüëç</span>
          </div>
          <div class="hidden sm:flex items-center gap-3 text-sm">
            <a href="#vault" class="text-gray-600 hover:text-gray-900">Vault</a>
            <a href="#thesis" class="text-gray-600 hover:text-gray-900"
              >Thesis</a
            >
          </div>
        </div>
      </header> -->

      <!-- HERO SECTION -->
      <section class="max-w-6xl mx-auto px-4 py-12 sm:py-16">
        <div class="text-center">
          <h1
            class="font-funny font-black text-6xl sm:text-8xl md:text-9xl tracking-tight shimmer-text reveal"
          >
            $ok
          </h1>

          <!-- Hero CTA: link to Meme Maker -->
          <div class="mt-6 reveal">
            <a
              href="#maker"
              id="hero-maker-btn"
              class="inline-flex items-center justify-center rounded-2xl px-5 py-4 text-base sm:text-lg font-semibold bg-black text-white shadow-lg shadow-gray-200 hover:bg-gray-900 transition-all duration-200 hover:scale-[1.02] hover-wiggle"
            >
              ok Meme Maker
            </a>
          </div>

          <!-- Contract address + Copy CTA (moved here instead of badges) -->
          <div
            class="mt-6 flex flex-col sm:flex-row items-stretch sm:items-center gap-4 reveal"
          >
            <div
              class="flex-1 bg-gray-50 border border-gray-200 rounded-2xl p-4 sm:p-5"
            >
              <div class="text-xs uppercase tracking-widest text-gray-500">
                Contract Address
              </div>
              <div
                id="ca-text"
                class="mt-2 font-mono text-base sm:text-lg md:text-xl break-all select-all"
              >
                F1h8SDKjX6P3pTNzuJYv1VhrEjbtMh76UZYRwiXjpump
              </div>
            </div>
            <button
              id="copy-btn"
              class="shrink-0 inline-flex items-center justify-center rounded-2xl px-5 py-4 text-base sm:text-lg font-semibold bg-emerald-500 text-white shadow-lg shadow-emerald-200 hover:bg-emerald-600 active:bg-emerald-700 transition-all duration-200 hover:scale-[1.02] pulse-soft hover-wiggle"
              aria-live="polite"
            >
              Copy CA üìã
            </button>
          </div>
          <p class="mt-2 text-xs text-gray-500">
            Tap to copy ‚Äî deploy the cat in your chats. üòøüëç (We only do
            emotions.)
          </p>
        </div>

        <!-- Main image placeholder -->
        <div class="mt-10">
          <div
            class="relative overflow-hidden rounded-2xl border border-gray-200 bg-gray-50 float-slow tilt-hover reveal"
          >
            <div class="aspect-[16/9]">
              <img
                src="banner.png"
                alt="Thumbs Up Crying Cat $ok banner"
                class="w-full h-full object-cover"
                loading="lazy"
              />
            </div>
          </div>
        </div>

        <!-- Contract address section moved above; removed here to avoid duplication -->
      </section>

      <!-- THESIS SECTION -->
      <section
        id="thesis"
        class="max-w-6xl mx-auto px-4 py-12 sm:py-16 border-t border-gray-100"
      >
        <h2 class="font-funny text-3xl sm:text-4xl font-black">
          The Thesis (Why We Are Tier-1)
        </h2>
        <div class="mt-6 grid sm:grid-cols-3 gap-6">
          <div class="p-5 border border-gray-200 rounded-2xl bg-white reveal">
            <div class="font-semibold text-lg">High Persistence üòº</div>
            <p class="mt-2 text-gray-700">
              Unlike your ex, we stick around. Not a one-week trend ‚Äî re-used
              across months, years, and every group chat meltdown.
            </p>
          </div>
          <div class="p-5 border border-gray-200 rounded-2xl bg-white reveal">
            <div class="font-semibold text-lg">Infinite Utility ‚ôæÔ∏è</div>
            <p class="mt-2 text-gray-700">
              Tier-1 reaction meme. Instantly readable emotion. Use for wins,
              losses, cope, and "it‚Äôs fine" denial arcs.
            </p>
          </div>
          <div class="p-5 border border-gray-200 rounded-2xl bg-white reveal">
            <div class="font-semibold text-lg">The Strategy üß™</div>
            <p class="mt-2 text-gray-700">
              It's not about the token; it's about deploying the cat as
              emotional punctuation in every chat on earth. Feel first.
              Speculate never (ok sometimes). üëç
            </p>
          </div>
        </div>
      </section>

      <!-- VAULT / GALLERY -->
      <section
        id="vault"
        class="max-w-6xl mx-auto px-4 py-12 sm:py-16 border-t border-gray-100"
      >
        <h2 class="font-funny text-3xl sm:text-4xl font-black">
          The Vault of Coping
        </h2>

        <div class="mt-6 grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
          <!-- Real meme images from /memes (square previews) -->
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/1.png"
              alt="$ok meme 1"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/2.png"
              alt="$ok meme 2"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/3.png"
              alt="$ok meme 3"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/4.png"
              alt="$ok meme 4"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/5.png"
              alt="$ok meme 5"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/6.png"
              alt="$ok meme 6"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/7.png"
              alt="$ok meme 7"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/8.png"
              alt="$ok meme 8"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/9.png"
              alt="$ok meme 9"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
          <div
            class="group relative aspect-square rounded-2xl border border-gray-200 bg-gray-50 overflow-hidden hover:scale-[1.02] transition-transform reveal"
          >
            <img
              src="memes/10.png"
              alt="$ok meme 10"
              class="w-full h-full object-cover"
              loading="lazy"
            />
          </div>
        </div>

        <div class="mt-8 flex justify-center">
          <button
            id="download-all"
            class="rounded-2xl px-5 py-4 text-base sm:text-lg font-semibold bg-black text-white hover:bg-gray-800 active:bg-gray-900 transition-colors hover-wiggle"
          >
            Download All (For Twitter arguments & life coping)
          </button>
        </div>
      </section>

      <!-- MEME MAKER -->
      <section
        id="maker"
        class="max-w-6xl mx-auto px-4 py-12 sm:py-16 border-t border-gray-100"
      >
        <h2 class="font-funny text-3xl sm:text-4xl font-black">
          ok Meme Maker
        </h2>
        <p class="mt-2 text-gray-600 text-sm">
          Drop a pic, slap on the ok Cat, then drag, rotate, flip. Copy to
          clipboard or download. üòøüëç
        </p>

        <div class="mt-6 grid lg:grid-cols-2 gap-6">
          <!-- Canvas area -->
          <div class="rounded-2xl border border-gray-200 bg-gray-50 p-3 reveal">
            <div
              class="aspect-square rounded-xl overflow-hidden bg-white flex items-center justify-center"
            >
              <canvas id="meme-canvas" class="w-full h-full"></canvas>
            </div>
          </div>

          <!-- Controls -->
          <div class="rounded-2xl border border-gray-200 bg-white p-4 reveal">
            <div class="flex flex-col gap-3">
              <div id="text-edit-section" class="hidden">
                <div class="text-sm text-gray-600 mt-3">Edit text:</div>
                <div class="mt-2 grid grid-cols-1 sm:grid-cols-3 gap-3">
                  <label class="block">
                    <span class="text-xs text-gray-600">Size</span>
                    <input id="text-size" type="range" min="20" max="200" step="2" class="w-full" />
                  </label>
                  <label class="block">
                    <span class="text-xs text-gray-600">Color</span>
                    <input id="text-color" type="color" value="#ffffff" class="w-full h-9 p-0 border border-gray-200 rounded-xl" />
                  </label>
                  <label class="block">
                    <span class="text-xs text-gray-600">Outline</span>
                    <input id="text-outline" type="range" min="0" max="16" step="1" value="6" class="w-full" />
                  </label>
                </div>
                <div class="mt-2 flex flex-wrap items-center gap-2">
                  <select
                    id="text-font"
                    class="px-3 py-2 rounded-xl border border-gray-200 focus:outline-none focus:ring-2 focus:ring-emerald-300"
                  >
                    <option value="anton">ok Loud</option>
                    <option value="comic-neue">ok Giggles</option>
                  </select>
                </div>
              </div>

              <div id="cat-edit-section" class="hidden">
                <div class="text-sm text-gray-600 mt-4">Edit cat:</div>
                <div class="mt-2 grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <label class="block">
                    <span class="text-sm text-gray-600">Scale</span>
                    <input
                      id="layer-scale"
                      type="range"
                      min="0.2"
                      max="3"
                      step="0.1"
                      class="w-full"
                    />
                  </label>
                  <label class="block">
                    <span class="text-sm text-gray-600">Rotation</span>
                    <input
                      id="layer-rotation"
                      type="range"
                      min="0"
                      max="360"
                      step="1"
                      class="w-full"
                    />
                  </label>
                </div>
                <div class="mt-2 flex items-center gap-3">
                  <button
                    id="flip-h"
                    class="px-3 py-2 rounded-xl bg-gray-100 hover:bg-gray-200"
                  >
                    Flip H
                  </button>
                  <button
                    id="flip-v"
                    class="px-3 py-2 rounded-xl bg-gray-100 hover:bg-gray-200"
                  >
                    Flip V
                  </button>
                  <button
                    id="delete-layer"
                    class="px-3 py-2 rounded-xl bg-red-500 text-white hover:bg-red-600"
                  >
                    Delete
                  </button>
                </div>
              </div>
              <div>
                <div class="text-sm text-gray-600">Upload base image</div>
                <div class="mt-2 flex items-center gap-3">
                  <input
                    id="meme-file"
                    type="file"
                    accept="image/*"
                    class="hidden"
                  />
                  <button
                    id="meme-upload"
                    class="px-4 py-2 rounded-xl bg-emerald-500 text-white font-semibold hover:bg-emerald-600 hover-wiggle"
                  >
                    Choose Image
                  </button>
                  <button
                    id="meme-use-template"
                    class="px-4 py-2 rounded-xl bg-gray-200 text-gray-900 font-semibold hover:bg-gray-300"
                  >
                    Use template
                  </button>
                  <button
                    id="meme-add-cat"
                    class="px-4 py-2 rounded-xl bg-black text-white font-semibold hover:bg-gray-800"
                  >
                    Add ok Cat
                  </button>
                </div>
              </div>
              <div class="mt-4">
                <div class="text-sm text-gray-600">Add text caption</div>
                <div class="mt-2 grid grid-cols-1 sm:grid-cols-2 gap-3">
                  <input
                    id="text-content"
                    type="text"
                    placeholder="Type your caption"
                    class="px-3 py-2 rounded-xl border border-gray-200 focus:outline-none focus:ring-2 focus:ring-emerald-300"
                  />
                  <button id="add-text" class="px-4 py-2 rounded-xl bg-black text-white font-semibold hover:bg-gray-800">Add Text</button>
                </div>
              </div>

              <div class="mt-3">
                <button
                  id="copy-meme"
                  class="w-full px-5 py-4 rounded-2xl bg-emerald-500 text-white font-semibold hover:bg-emerald-600 hover-wiggle"
                >
                  Copy to Clipboard
                </button>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- FOOTER -->
      <footer class="border-t border-gray-100">
        <div class="max-w-6xl mx-auto px-4 py-10">
          <div
            class="flex flex-col sm:flex-row items-center justify-between gap-4"
          >
            <div class="flex items-center gap-4">
              <a
                href="https://x.com/okcryingcat"
                class="text-gray-700 hover:text-black font-semibold"
                >X (Twitter)</a
              >
              <span class="text-gray-300">‚Ä¢</span>
              <a
                href="https://x.com/i/communities/2000438470347747829"
                class="text-gray-700 hover:text-black font-semibold"
                >Community</a
              >
              <span class="text-gray-300">‚Ä¢</span>
              <a
                href="https://knowyourmeme.com/memes/thumbs-up-crying-cat"
                target="_blank"
                rel="noopener noreferrer"
                class="text-gray-700 hover:text-black font-semibold"
                aria-label="KnowYourMeme page: Thumbs Up Crying Cat"
              >
                KnowYourMeme
              </a>
            </div>
            <div class="text-xs text-gray-500">
              ¬© 2025 $ok. We are literally just a cat giving a thumbs up. NFA.
              DYOR on feelings.
            </div>
          </div>
        </div>
      </footer>
    </main>

    <!-- Scripts -->
    <script>
      // Copy-to-clipboard with satisfying animation and status updates
      const copyBtn = document.getElementById("copy-btn");
      const caText = document.getElementById("ca-text");
      const originalBtnText = copyBtn.textContent;

      async function copyCA() {
        const text = caText.textContent.trim();
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            // Fallback: create a temporary textarea
            const t = document.createElement("textarea");
            t.value = text;
            document.body.appendChild(t);
            t.select();
            document.execCommand("copy");
            document.body.removeChild(t);
          }

          // Visual feedback
          copyBtn.textContent = "Copied! üòøüëç";
          copyBtn.classList.add("animate-ok-pop");
          copyBtn.classList.add("ring-2", "ring-emerald-300", "shadow-pop");

          // Emoji burst confetti
          burstEmojis(["üòø", "üëç", "üí¨", "‚ú®"]);

          // Revert after a moment
          setTimeout(() => {
            copyBtn.textContent = originalBtnText;
            copyBtn.classList.remove("animate-ok-pop");
            copyBtn.classList.remove(
              "ring-2",
              "ring-emerald-300",
              "shadow-pop"
            );
          }, 1200);
        } catch (err) {
          console.error("Copy failed:", err);
          copyBtn.textContent = "Something broke üòø";
          setTimeout(() => (copyBtn.textContent = originalBtnText), 1500);
        }
      }

      copyBtn.addEventListener("click", copyCA);

      // Utility: ensure JSZip is available (load on demand)
      function loadJSZip() {
        return new Promise((resolve, reject) => {
          if (window.JSZip) return resolve();
          const add = (src) =>
            new Promise((res, rej) => {
              const s = document.createElement("script");
              s.src = src;
              s.crossOrigin = "anonymous";
              s.referrerPolicy = "no-referrer";
              s.onload = () => res();
              s.onerror = () => rej(new Error("Failed to load " + src));
              document.head.appendChild(s);
            });
          add(
            "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
          )
            .then(resolve)
            .catch(() =>
              add("https://unpkg.com/jszip@3.10.1/dist/jszip.min.js")
                .then(resolve)
                .catch(reject)
            );
        });
      }

      // Download All: fetch memes/1.png..10.png and zip to ok.zip
      document
        .getElementById("download-all")
        .addEventListener("click", async () => {
          const btn = document.getElementById("download-all");
          const original = btn.textContent;
          btn.disabled = true;
          btn.textContent = "Preparing ZIP‚Ä¶";
          try {
            await loadJSZip();
            const zip = new JSZip();
            const folder = zip.folder("ok");
            const files = Array.from(
              { length: 10 },
              (_, i) => `memes/${i + 1}.png`
            );

            // Fetch images as ArrayBuffers
            const buffers = await Promise.all(
              files.map(async (path) => {
                const res = await fetch(path);
                if (!res.ok) throw new Error(`Failed to fetch ${path}`);
                const buf = await res.arrayBuffer();
                return { name: path.split("/").pop(), buf };
              })
            );

            // Add to zip under ok/
            for (const { name, buf } of buffers) {
              folder.file(name, buf);
            }

            // Generate ZIP and trigger download
            const blob = await zip.generateAsync({ type: "blob" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "ok.zip";
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            btn.textContent = "Downloaded ok.zip üëç";
            burstEmojis(["üì¶", "üòø", "üëç", "‚ú®"]);
            setTimeout(() => (btn.textContent = original), 1400);
          } catch (e) {
            console.error(e);
            btn.textContent = "Download failed üòø";
            setTimeout(() => (btn.textContent = original), 1600);
          } finally {
            btn.disabled = false;
          }
        });

      // Simple emoji burst confetti
      function burstEmojis(list) {
        const container = document.createElement("div");
        container.style.position = "fixed";
        container.style.left = "0";
        container.style.top = "0";
        container.style.width = "100%";
        container.style.height = "100%";
        container.style.pointerEvents = "none";
        container.className = "emoji-burst";
        document.body.appendChild(container);

        const count = 14;
        for (let i = 0; i < count; i++) {
          const span = document.createElement("span");
          span.textContent = list[Math.floor(Math.random() * list.length)];
          span.style.position = "absolute";
          span.style.left = Math.random() * 100 + "%";
          span.style.top = "50%";
          span.style.fontSize = 16 + Math.random() * 18 + "px";
          span.style.opacity = "0";
          span.style.transform = "translate(-50%, 0)";
          span.className = "emoji";
          container.appendChild(span);

          // random animation duration & horizontal drift via CSS variables
          const drift = Math.random() * 60 - 30 + "px";
          span.style.setProperty("--drift", drift);
          span.style.setProperty(
            "--fade",
            (0.6 + Math.random() * 0.6).toString()
          );
        }

        // remove after animation
        setTimeout(() => {
          document.body.removeChild(container);
        }, 1200);
      }

      // Scroll reveal observer
      const observer = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (entry.isIntersecting) {
              entry.target.classList.add("reveal-visible");
              observer.unobserve(entry.target);
            }
          }
        },
        { threshold: 0.12 }
      );

      document
        .querySelectorAll(".reveal")
        .forEach((el) => observer.observe(el));

      // Floating background cats
      const floatContainer = document.getElementById("bg-floats");
      function spawnCatFloat() {
        const img = document.createElement("img");
        img.src = "catnobg.png";
        img.className = "cat-float";

        // Random size: 60px ‚Äì 240px
        const size = Math.floor(60 + Math.random() * 180);
        img.style.setProperty("--size", size + "px");

        // Direction: left-to-right or right-to-left
        const leftToRight = Math.random() < 0.5;
        const fromX = leftToRight ? "-20vw" : "120vw";
        const toX = leftToRight ? "120vw" : "-20vw";

        // Vertical path: random start/end along viewport
        const fromY = Math.floor(Math.random() * 100) + "vh";
        const toY = Math.floor(Math.random() * 100) + "vh";

        // Gentle rotation variance
        const fromR = (Math.random() * 20 - 10).toFixed(1) + "deg";
        const toR = (Math.random() * 20 - 10).toFixed(1) + "deg";

        // Duration: 12s ‚Äì 30s
        const dur = (12 + Math.random() * 18).toFixed(1) + "s";

        img.style.setProperty("--fromX", fromX);
        img.style.setProperty("--toX", toX);
        img.style.setProperty("--fromY", fromY);
        img.style.setProperty("--toY", toY);
        img.style.setProperty("--fromR", fromR);
        img.style.setProperty("--toR", toR);
        img.style.setProperty("--dur", dur);

        floatContainer.appendChild(img);
        img.addEventListener("animationend", () => {
          img.remove();
        });
      }

      function startCatFloats() {
        // Seed a few cats
        for (let i = 0; i < 4; i++) spawnCatFloat();

        // Keep spawning, with a soft cap
        const maxConcurrent = 8;
        function loop() {
          if (floatContainer.childElementCount < maxConcurrent) {
            spawnCatFloat();
          }
          const next = 1500 + Math.random() * 2500; // 1.5s ‚Äì 4s
          setTimeout(loop, next);
        }
        loop();
      }

      // Initialize after page loads
      document.addEventListener("DOMContentLoaded", startCatFloats);

      // Meme Maker logic: canvas rendering and controls
      (function memeMaker() {
        const canvas = document.getElementById("meme-canvas");
        if (!canvas) return;
        const ctx = canvas.getContext("2d");

        // State
        let baseImage = null; // HTMLImageElement
        const layers = []; // overlay layers
        let selectedLayerId = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        // Controls
        const fileInput = document.getElementById("meme-file");
        const uploadBtn = document.getElementById("meme-upload");
        const templateBtn = document.getElementById("meme-use-template");
        const addCatBtn = document.getElementById("meme-add-cat");
        const scaleInput = document.getElementById("layer-scale");
        const rotInput = document.getElementById("layer-rotation");
        const flipHBtn = document.getElementById("flip-h");
        const flipVBtn = document.getElementById("flip-v");
        const delBtn = document.getElementById("delete-layer");
        const copyBtn = document.getElementById("copy-meme");

        // Viewport-based behavior: prefer download on small screens
        let preferDownload = window.matchMedia("(max-width: 799px)").matches;
        function updateCopyBtnLabel() {
          if (!copyBtn) return;
          copyBtn.textContent = preferDownload ? "Download Meme" : "Copy to Clipboard";
        }
        updateCopyBtnLabel();
        const mq = window.matchMedia("(max-width: 799px)");
        // Update on MQ change
        if (mq && mq.addEventListener) {
          mq.addEventListener("change", (e) => {
            preferDownload = e.matches;
            updateCopyBtnLabel();
          });
        }
        // Fallback: update on resize
        window.addEventListener("resize", () => {
          const current = window.innerWidth < 800;
          if (current !== preferDownload) {
            preferDownload = current;
            updateCopyBtnLabel();
          }
        });

        // Text controls
        const textInput = document.getElementById("text-content");
        const textFont = document.getElementById("text-font");
        const textSize = document.getElementById("text-size");
        const textColor = document.getElementById("text-color");
        const textOutline = document.getElementById("text-outline");
        const addTextBtn = document.getElementById("add-text");
        const textEditSection = document.getElementById("text-edit-section");
        const catEditSection = document.getElementById("cat-edit-section");

        // Resize canvas to square container size with devicePixelRatio
        function resizeCanvas() {
          const parent = canvas.parentElement;
          const size = parent.clientWidth; // aspect-square container
          const dpr = window.devicePixelRatio || 1;
          canvas.width = Math.max(1, Math.floor(size * dpr));
          canvas.height = Math.max(1, Math.floor(size * dpr));
          canvas.style.width = size + "px";
          canvas.style.height = size + "px";
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(dpr, dpr);
          draw();
        }
        window.addEventListener("resize", resizeCanvas);
        requestAnimationFrame(resizeCanvas);

        function clearCanvas() {
          const w = canvas.width / (window.devicePixelRatio || 1);
          const h = canvas.height / (window.devicePixelRatio || 1);
          ctx.clearRect(0, 0, w, h);
        }

        function draw() {
          clearCanvas();
          const w = canvas.width / (window.devicePixelRatio || 1);
          const h = canvas.height / (window.devicePixelRatio || 1);
          let fitRect = null;
          // Draw base image fit contain
          if (baseImage) {
            const fit = contain(
              baseImage.naturalWidth,
              baseImage.naturalHeight,
              w,
              h
            );
            ctx.drawImage(baseImage, fit.x, fit.y, fit.width, fit.height);
            fitRect = fit;
            // Clip overlays to the bounds of the base image
            ctx.save();
            ctx.beginPath();
            ctx.rect(fit.x, fit.y, fit.width, fit.height);
            ctx.clip();
          } else {
            // Placeholder background
            ctx.fillStyle = "#f8fafc";
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = "#94a3b8";
            ctx.textAlign = "center";
            ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto";
            ctx.fillText("Upload an image or Add ok Cat", w / 2, h / 2);
          }

          // Draw layers
          for (const layer of layers) {
            if (layer.type === "text") {
              drawTextLayer(layer);
            } else {
              drawImageLayer(layer);
            }
          }

          // Restore clipping if applied
          if (fitRect) {
            ctx.restore();
          }
        }

        function contain(srcW, srcH, maxW, maxH) {
          const ratio = Math.min(maxW / srcW, maxH / srcH);
          const width = srcW * ratio;
          const height = srcH * ratio;
          const x = (maxW - width) / 2;
          const y = (maxH - height) / 2;
          return { x, y, width, height, ratio };
        }

        function drawImageLayer(layer) {
          const imgW = layer.image.naturalWidth * layer.scale;
          const imgH = layer.image.naturalHeight * layer.scale;

          ctx.save();
          ctx.translate(layer.x, layer.y);
          ctx.rotate((layer.rotation * Math.PI) / 180);
          ctx.scale(layer.flipH ? -1 : 1, layer.flipV ? -1 : 1);
          ctx.drawImage(layer.image, -imgW / 2, -imgH / 2, imgW, imgH);
          if (layer.id === selectedLayerId) {
            ctx.strokeStyle = "#10b981";
            ctx.lineWidth = 2;
            ctx.strokeRect(-imgW / 2, -imgH / 2, imgW, imgH);
          }
          ctx.restore();
        }

        function textFamilyFrom(value) {
          return value === "anton" ? "Anton, Impact, sans-serif" : "'Comic Neue', 'Comic Sans MS', cursive";
        }

        function drawTextLayer(layer) {
          const w = canvas.width / (window.devicePixelRatio || 1);
          const h = canvas.height / (window.devicePixelRatio || 1);
          const text = layer.text;
          ctx.save();
          ctx.translate(layer.x, layer.y);
          ctx.rotate((layer.rotation * Math.PI) / 180);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `${layer.weight} ${Math.max(8, layer.fontSize)}px ${textFamilyFrom(layer.font)}`;
          ctx.lineJoin = "round";
          if (layer.strokeWidth > 0) {
            ctx.strokeStyle = layer.stroke;
            ctx.lineWidth = layer.strokeWidth;
            ctx.strokeText(text, 0, 0);
          }
          ctx.fillStyle = layer.fill;
          ctx.fillText(text, 0, 0);
          if (layer.id === selectedLayerId) {
            // selection guide box
            const m = ctx.measureText(text);
            const tw = m.width;
            const th = layer.fontSize * 1.2;
            ctx.strokeStyle = "#10b981";
            ctx.lineWidth = 2;
            ctx.strokeRect(-tw / 2, -th / 2, tw, th);
          }
          ctx.restore();
        }

        function createCatLayer() {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              const w = canvas.width / (window.devicePixelRatio || 1);
              const h = canvas.height / (window.devicePixelRatio || 1);
              const size = Math.min(w, h) * 0.4;
              const scale = size / img.naturalWidth;
              const layer = {
                id: "layer-" + Math.random().toString(36).slice(2),
                image: img,
                x: w / 2,
                y: h / 2,
                scale,
                rotation: 0,
                flipH: false,
                flipV: false,
              };
              resolve(layer);
            };
            img.onerror = reject;
            img.src = "catnobg.png";
          });
        }

        function selectLayerByPoint(px, py) {
          // Check from topmost to bottom for point-in-rotated-rect
          for (let i = layers.length - 1; i >= 0; i--) {
            const layer = layers[i];
            const dx = px - layer.x;
            const dy = py - layer.y;
            const rad = (-layer.rotation * Math.PI) / 180;
            const cos = Math.cos(rad),
              sin = Math.sin(rad);
            const lx = dx * cos - dy * sin;
            const ly = dx * sin + dy * cos;
            let bw = 0, bh = 0;
            if (layer.type === "text") {
              ctx.save();
              ctx.font = `${layer.weight} ${Math.max(8, layer.fontSize)}px ${textFamilyFrom(layer.font)}`;
              const m = ctx.measureText(layer.text);
              ctx.restore();
              bw = m.width;
              bh = layer.fontSize * 1.2;
            } else {
              bw = layer.image.naturalWidth * layer.scale;
              bh = layer.image.naturalHeight * layer.scale;
            }
            if (Math.abs(lx) <= bw / 2 && Math.abs(ly) <= bh / 2) {
              selectedLayerId = layer.id;
              if (layer.type !== "text") {
                scaleInput.value = String(layer.scale);
              }
              rotInput.value = String(layer.rotation);
              // Reflect text layer values into UI
              if (layer.type === "text") {
                textInput.value = layer.text;
                textFont.value = layer.font;
                textSize.value = String(layer.fontSize);
                textColor.value = layer.fill;
                textOutline.value = String(layer.strokeWidth);
              }
              // Toggle edit sections visibility
              if (textEditSection) {
                textEditSection.classList.toggle("hidden", layer.type !== "text");
              }
              if (catEditSection) {
                catEditSection.classList.toggle("hidden", layer.type !== "image");
              }
              return layer;
            }
          }
          // If no layer hit, clear selection and hide sections
          selectedLayerId = null;
          if (textEditSection) textEditSection.classList.add("hidden");
          if (catEditSection) catEditSection.classList.add("hidden");
          return null;
        }

        // Events
        uploadBtn.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", () => {
          const file = fileInput.files?.[0];
          if (!file) return;
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            baseImage = img;
            URL.revokeObjectURL(url);
            draw();
          };
          img.src = url;
        });

        // Use template.png as base image
        if (templateBtn) {
          templateBtn.addEventListener("click", () => {
            const img = new Image();
            img.onload = () => {
              baseImage = img;
              draw();
            };
            img.src = "template.png";
          });
        }

        addCatBtn.addEventListener("click", async () => {
          try {
            const layer = await createCatLayer();
            layer.type = "image";
            layers.push(layer);
            selectedLayerId = layer.id;
            scaleInput.value = String(layer.scale);
            rotInput.value = String(layer.rotation);
            if (textEditSection) textEditSection.classList.add("hidden");
            if (catEditSection) catEditSection.classList.remove("hidden");
            draw();
          } catch (e) {
            alert("Failed to load cat image");
          }
        });

        scaleInput.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.scale = parseFloat(scaleInput.value);
          draw();
        });
        rotInput.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.rotation = parseFloat(rotInput.value);
          draw();
        });

        flipHBtn.addEventListener("click", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.flipH = !layer.flipH;
          draw();
        });
        flipVBtn.addEventListener("click", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.flipV = !layer.flipV;
          draw();
        });
        delBtn.addEventListener("click", () => {
          const idx = layers.findIndex((l) => l.id === selectedLayerId);
          if (idx >= 0) {
            layers.splice(idx, 1);
            selectedLayerId = null;
            draw();
          }
        });

        // Text layer creation helpers
        function createTextLayerAt(yPos) {
          const w = canvas.width / (window.devicePixelRatio || 1);
          const h = canvas.height / (window.devicePixelRatio || 1);
          const font = textFont.value || "anton";
          const layer = {
            id: "layer-" + Math.random().toString(36).slice(2),
            type: "text",
            text: (textInput.value || "ok").trim(),
            font,
            weight: font === "anton" ? "700" : "700",
            fontSize: parseInt(textSize.value || "72", 10),
            fill: textColor.value || "#ffffff",
            stroke: "#000000",
            strokeWidth: parseInt(textOutline.value || "6", 10),
            x: w / 2,
            y: yPos ?? h / 2,
            rotation: 0,
            flipH: false,
            flipV: false,
          };
          return layer;
        }

        function addTextCommon(yPos) {
          const layer = createTextLayerAt(yPos);
          layers.push(layer);
          selectedLayerId = layer.id;
          rotInput.value = String(layer.rotation);
          if (catEditSection) catEditSection.classList.add("hidden");
          if (textEditSection) textEditSection.classList.remove("hidden");
          draw();
        }

        addTextBtn.addEventListener("click", () => addTextCommon());
        // Live update: size, color, outline, font
        textSize.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.fontSize = parseInt(textSize.value || String(layer.fontSize), 10);
          draw();
        });
        textColor.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.fill = textColor.value || layer.fill;
          draw();
        });
        textOutline.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.strokeWidth = parseInt(textOutline.value || String(layer.strokeWidth), 10);
          draw();
        });
        textFont.addEventListener("change", async () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.font = textFont.value || layer.font;
          if (document.fonts && document.fonts.ready) {
            try { await document.fonts.ready; } catch {}
          }
          draw();
        });
        // Optional: live text content editing
        textInput.addEventListener("input", () => {
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer || layer.type !== "text") return;
          layer.text = (textInput.value || "").trim();
          draw();
        });

        // Pointer dragging
        function canvasPoint(evt) {
          const rect = canvas.getBoundingClientRect();
          const x = evt.clientX - rect.left;
          const y = evt.clientY - rect.top;
          return { x, y };
        }
        canvas.addEventListener("mousedown", (evt) => {
          const { x, y } = canvasPoint(evt);
          const layer = selectLayerByPoint(x, y);
          if (layer) {
            isDragging = true;
            dragOffset.x = x - layer.x;
            dragOffset.y = y - layer.y;
            draw();
          } else {
            // Hide edit sections if clicking empty space
            if (textEditSection) textEditSection.classList.add("hidden");
            if (catEditSection) catEditSection.classList.add("hidden");
            draw();
          }
        });
        window.addEventListener("mousemove", (evt) => {
          if (!isDragging) return;
          const { x, y } = canvasPoint(evt);
          const layer = layers.find((l) => l.id === selectedLayerId);
          if (!layer) return;
          layer.x = x - dragOffset.x;
          layer.y = y - dragOffset.y;
          draw();
        });
        window.addEventListener("mouseup", () => {
          isDragging = false;
        });

        // Touch dragging
        canvas.addEventListener(
          "touchstart",
          (evt) => {
            const t = evt.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = t.clientX - rect.left;
            const y = t.clientY - rect.top;
            const layer = selectLayerByPoint(x, y);
            if (layer) {
              // Prevent page scroll while initiating a drag on canvas
              evt.preventDefault();
              isDragging = true;
              dragOffset.x = x - layer.x;
              dragOffset.y = y - layer.y;
              // Hint to browsers to disable touch scrolling while active
              canvas.style.touchAction = "none";
              draw();
            }
          },
          { passive: false }
        );
        canvas.addEventListener(
          "touchmove",
          (evt) => {
            if (!isDragging) return;
            // Prevent page scroll while dragging on canvas
            evt.preventDefault();
            const t = evt.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = t.clientX - rect.left;
            const y = t.clientY - rect.top;
            const layer = layers.find((l) => l.id === selectedLayerId);
            if (!layer) return;
            layer.x = x - dragOffset.x;
            layer.y = y - dragOffset.y;
            draw();
          },
          { passive: false }
        );
        canvas.addEventListener(
          "touchend",
          () => {
            isDragging = false;
            // Restore default touch behavior when not dragging
            canvas.style.touchAction = "";
          },
          { passive: false }
        );

        // Copy to clipboard or download based on viewport preference
        copyBtn.addEventListener("click", async () => {
          const dpr = window.devicePixelRatio || 1;
          const w = canvas.width / dpr;
          const h = canvas.height / dpr;

          // Determine export area: if base image exists, export only its fitted region
          let exportW = Math.floor(w);
          let exportH = Math.floor(h);
          let offsetX = 0;
          let offsetY = 0;

          let fit = null;
          if (baseImage) {
            fit = contain(
              baseImage.naturalWidth,
              baseImage.naturalHeight,
              w,
              h
            );
            exportW = Math.floor(fit.width);
            exportH = Math.floor(fit.height);
            offsetX = fit.x;
            offsetY = fit.y;
          }

          const off = document.createElement("canvas");
          off.width = exportW;
          off.height = exportH;
          const octx = off.getContext("2d");

          if (baseImage && fit) {
            // Draw only the fitted base image region
            octx.drawImage(baseImage, 0, 0, fit.width, fit.height);
          } else {
            // No base image; export the full canvas area
            octx.fillStyle = "#ffffff";
            octx.fillRect(0, 0, exportW, exportH);
          }

          // Draw overlays, shifted so (0,0) == top-left of fitted base image
          for (const layer of layers) {
            octx.save();
            const tx = layer.x - offsetX;
            const ty = layer.y - offsetY;
            octx.translate(tx, ty);
            octx.rotate((layer.rotation * Math.PI) / 180);
            octx.scale(layer.flipH ? -1 : 1, layer.flipV ? -1 : 1);
            if (layer.type === "text") {
              const text = layer.text;
              octx.textAlign = "center";
              octx.textBaseline = "middle";
              octx.font = `${layer.weight} ${Math.max(8, layer.fontSize)}px ${textFamilyFrom(layer.font)}`;
              octx.lineJoin = "round";
              if (layer.strokeWidth > 0) {
                octx.strokeStyle = layer.stroke;
                octx.lineWidth = layer.strokeWidth;
                octx.strokeText(text, 0, 0);
              }
              octx.fillStyle = layer.fill;
              octx.fillText(text, 0, 0);
            } else {
              const imgW = layer.image.naturalWidth * layer.scale;
              const imgH = layer.image.naturalHeight * layer.scale;
              octx.drawImage(layer.image, -imgW / 2, -imgH / 2, imgW, imgH);
            }
            octx.restore();
          }

          if (document.fonts && document.fonts.ready) {
            try { await document.fonts.ready; } catch {}
          }

          try {
            const blob = await new Promise((res) => off.toBlob(res, "image/png"));
            if (!blob) throw new Error("Blob unavailable");
            const doCopy = !preferDownload && navigator.clipboard && window.ClipboardItem;
            if (doCopy) {
              await navigator.clipboard.write([
                new ClipboardItem({ "image/png": blob }),
              ]);
              const original = copyBtn.textContent;
              copyBtn.textContent = "Copied! üòøüëç";
              burstEmojis(["üòø", "üëç", "‚ú®", "üñºÔ∏è"]);
              setTimeout(() => (copyBtn.textContent = original), 1200);
            } else {
              const url = URL.createObjectURL(blob);
              const a = document.createElement("a");
              a.href = url;
              a.download = "ok-meme.png";
              document.body.appendChild(a);
              a.click();
              a.remove();
              URL.revokeObjectURL(url);
              const original = copyBtn.textContent;
              copyBtn.textContent = "Downloaded ok-meme.png";
              burstEmojis(["üì•", "üòø", "üëç", "‚ú®"]);
              setTimeout(() => (copyBtn.textContent = original), 1400);
            }
          } catch (err) {
            alert("Failed to copy/download");
          }
        });
      })();
    </script>
  </body>
</html>
